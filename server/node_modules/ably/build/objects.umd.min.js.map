{
  "version": 3,
  "sources": ["../src/plugins/objects/index.ts", "../src/plugins/objects/objectmessage.ts", "../src/plugins/objects/liveobject.ts", "../src/plugins/objects/objectid.ts", "../src/plugins/objects/livecounter.ts", "../src/plugins/objects/batchcontextlivecounter.ts", "../node_modules/dequal/dist/index.mjs", "../src/plugins/objects/livemap.ts", "../src/plugins/objects/batchcontextlivemap.ts", "../src/plugins/objects/defaults.ts", "../src/plugins/objects/objectspool.ts", "../src/plugins/objects/batchcontext.ts", "../src/plugins/objects/syncobjectsdatapool.ts", "../src/plugins/objects/objects.ts"],
  "sourcesContent": ["import { ObjectMessage, WireObjectMessage } from './objectmessage';\nimport { Objects } from './objects';\n\nexport { Objects, ObjectMessage, WireObjectMessage };\n\nexport default {\n  Objects,\n  ObjectMessage,\n  WireObjectMessage,\n};\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type { MessageEncoding } from 'common/lib/types/basemessage';\nimport type * as Utils from 'common/lib/util/utils';\nimport type { Bufferlike } from 'common/platform';\nimport type { JsonArray, JsonObject } from '../../../ably';\n\nexport type EncodeObjectDataFunction = (data: ObjectData | WireObjectData) => WireObjectData;\n\n/** @spec OOP2 */\nexport enum ObjectOperationAction {\n  MAP_CREATE = 0,\n  MAP_SET = 1,\n  MAP_REMOVE = 2,\n  COUNTER_CREATE = 3,\n  COUNTER_INC = 4,\n  OBJECT_DELETE = 5,\n}\n\n/** @spec OMP2 */\nexport enum ObjectsMapSemantics {\n  LWW = 0,\n}\n\nexport type PrimitiveObjectValue = string | number | boolean | Bufferlike | JsonArray | JsonObject;\n\n/**\n * An ObjectData represents a value in an object on a channel decoded from {@link WireObjectData}.\n * @spec OD1\n */\nexport interface ObjectData {\n  /** A reference to another object, used to support composable object structures. */\n  objectId?: string; // OD2a\n  /** A decoded leaf value from {@link WireObjectData}. */\n  value?: PrimitiveObjectValue;\n}\n\n/**\n * A WireObjectData represents a value in an object on a channel received from the server.\n * @spec OD1\n */\nexport interface WireObjectData {\n  /** A reference to another object, used to support composable object structures. */\n  objectId?: string; // OD2a\n\n  /** A primitive boolean leaf value in the object graph. Only one value field can be set. */\n  boolean?: boolean; // OD2c\n  /** A primitive binary leaf value in the object graph. Only one value field can be set. Represented as a Base64-encoded string in JSON protocol */\n  bytes?: Bufferlike | string; // OD2d\n  /** A primitive number leaf value in the object graph. Only one value field can be set. */\n  number?: number; // OD2e\n  /** A primitive string leaf value in the object graph. Only one value field can be set. */\n  string?: string; // OD2f\n  /** A primitive JSON-encoded string leaf value in the object graph. Only one value field can be set. */\n  json?: string; // OD2g\n}\n\n/**\n * An ObjectsMapOp describes an operation to be applied to a Map object.\n * @spec OMO1\n */\nexport interface ObjectsMapOp<TData> {\n  /** The key of the map entry to which the operation should be applied. */\n  key: string; // OMO2a\n  /** The data that the map entry should contain if the operation is a MAP_SET operation. */\n  data?: TData; // OMO2b\n}\n\n/**\n * An ObjectsCounterOp describes an operation to be applied to a Counter object.\n * @spec OCO1\n */\nexport interface ObjectsCounterOp {\n  /** The data value that should be added to the counter */\n  amount: number; // OCO2a\n}\n\n/**\n * An ObjectsMapEntry represents the value at a given key in a Map object.\n * @spec OME1\n */\nexport interface ObjectsMapEntry<TData> {\n  /** Indicates whether the map entry has been removed. */\n  tombstone?: boolean; // OME2a\n  /**\n   * The {@link ObjectMessage.serial} value of the last operation that was applied to the map entry.\n   *\n   * It is optional in a MAP_CREATE operation and might be missing, in which case the client should use a nullish value for it\n   * and treat it as the \"earliest possible\" serial for comparison purposes.\n   */\n  timeserial?: string; // OME2b\n  /** A timestamp from the {@link timeserial} field. Only present if {@link tombstone} is `true` */\n  serialTimestamp?: number; // OME2d\n  /** The data that represents the value of the map entry. */\n  data?: TData; // OME2c\n}\n\n/**\n * An ObjectsMap object represents a map of key-value pairs.\n * @spec OMP1\n */\nexport interface ObjectsMap<TData> {\n  /** The conflict-resolution semantics used by the map object. */\n  semantics?: ObjectsMapSemantics; // OMP3a\n  // The map entries, indexed by key.\n  entries?: Record<string, ObjectsMapEntry<TData>>; // OMP3b\n}\n\n/**\n * An ObjectsCounter object represents an incrementable and decrementable value\n * @spec OCN1\n */\nexport interface ObjectsCounter {\n  /** The value of the counter */\n  count?: number; // OCN2a\n}\n\n/**\n * An ObjectOperation describes an operation to be applied to an object on a channel.\n * @spec OOP1\n */\nexport interface ObjectOperation<TData> {\n  /** Defines the operation to be applied to the object. */\n  action: ObjectOperationAction; // OOP3a\n  /** The object ID of the object on a channel to which the operation should be applied. */\n  objectId: string; // OOP3b\n  /** The payload for the operation if it is an operation on a Map object type. */\n  mapOp?: ObjectsMapOp<TData>; // OOP3c\n  /** The payload for the operation if it is an operation on a Counter object type. */\n  counterOp?: ObjectsCounterOp; // OOP3d\n  /**\n   * The payload for the operation if the operation is MAP_CREATE.\n   * Defines the initial value for the Map object.\n   */\n  map?: ObjectsMap<TData>; // OOP3e\n  /**\n   * The payload for the operation if the operation is COUNTER_CREATE.\n   * Defines the initial value for the Counter object.\n   */\n  counter?: ObjectsCounter; // OOP3f\n  /**\n   * The nonce, must be present on create operations. This is the random part\n   * that has been hashed with the type and initial value to create the object ID.\n   */\n  nonce?: string; // OOP3g\n  /**\n   * The initial value of the object, represented as a JSON string.\n   * Used along with the nonce and timestamp to create the object ID.\n   *\n   * This field must be set by the client for MAP_CREATE and COUNTER_CREATE operations.\n   * The server uses it to verify the object ID, and after verification, the JSON string\n   * is decoded into the initial value for new Map or Counter objects.\n   *\n   * This field must not be read by the client if received from the server.\n   */\n  initialValue?: string; // OOP3h\n}\n\n/**\n * An ObjectState describes the instantaneous state of an object on a channel.\n * @spec OST1\n */\nexport interface ObjectState<TData> {\n  /** The identifier of the object. */\n  objectId: string; // OST2a\n  /** A map of serials keyed by a {@link ObjectMessage.siteCode}, representing the last operations applied to this object */\n  siteTimeserials: Record<string, string>; // OST2b\n  /** True if the object has been tombstoned. */\n  tombstone: boolean; // OST2c\n  /**\n   * The operation that created the object.\n   *\n   * Can be missing if create operation for the object is not known at this point.\n   */\n  createOp?: ObjectOperation<TData>; // OST2d\n  /**\n   * The data that represents the result of applying all operations to a Map object\n   * excluding the initial value from the create operation if it is a Map object type.\n   */\n  map?: ObjectsMap<TData>; // OST2e\n  /**\n   * The data that represents the result of applying all operations to a Counter object\n   * excluding the initial value from the create operation if it is a Counter object type.\n   */\n  counter?: ObjectsCounter; // OST2f\n}\n\nfunction encode(\n  message: Utils.Properties<ObjectMessage> | Utils.Properties<WireObjectMessage>,\n  utils: typeof Utils,\n  messageEncoding: typeof MessageEncoding,\n  encodeObjectDataFn: EncodeObjectDataFunction,\n): WireObjectMessage {\n  // deep copy the message to avoid mutating the original one.\n  // buffer values won't be correctly copied, so we will need to use the original message when encoding.\n  const result = Object.assign(new WireObjectMessage(utils, messageEncoding), copyMsg(message));\n\n  // encode \"object\" field\n  if (message.object?.map?.entries) {\n    result.object!.map!.entries = encodeMapEntries(message.object.map.entries, encodeObjectDataFn);\n  }\n\n  if (message.object?.createOp?.map?.entries) {\n    result.object!.createOp!.map!.entries = encodeMapEntries(message.object.createOp.map.entries, encodeObjectDataFn);\n  }\n\n  if (message.object?.createOp?.mapOp?.data) {\n    result.object!.createOp!.mapOp!.data = encodeObjectData(message.object.createOp.mapOp.data, encodeObjectDataFn);\n  }\n\n  // OOP5\n  // encode \"operation\" field\n  if (message.operation?.map?.entries) {\n    result.operation!.map!.entries = encodeMapEntries(message.operation.map.entries, encodeObjectDataFn);\n  }\n\n  if (message.operation?.mapOp?.data) {\n    result.operation!.mapOp!.data = encodeObjectData(message.operation.mapOp.data, encodeObjectDataFn);\n  }\n\n  return result;\n}\n\nfunction encodeMapEntries(\n  mapEntries: Record<string, ObjectsMapEntry<ObjectData | WireObjectData>>,\n  encodeFn: EncodeObjectDataFunction,\n): Record<string, ObjectsMapEntry<WireObjectData>> {\n  return Object.entries(mapEntries).reduce(\n    (acc, v) => {\n      const [key, entry] = v;\n      const encodedData = entry.data ? encodeObjectData(entry.data, encodeFn) : undefined;\n      acc[key] = {\n        ...entry,\n        data: encodedData,\n      };\n      return acc;\n    },\n    {} as Record<string, ObjectsMapEntry<WireObjectData>>,\n  );\n}\n\n/** @spec OD4 */\nfunction encodeObjectData(data: ObjectData | WireObjectData, encodeFn: EncodeObjectDataFunction): WireObjectData {\n  const encodedData = encodeFn(data);\n  return encodedData;\n}\n\n/**\n * Used to create an {@link ObjectOperation.initialValue} JSON string for *_CREATE operations,\n * based on the object operation message that contains the initial value for the object.\n */\nexport function createInitialValueJSONString(\n  operation: Partial<ObjectOperation<ObjectData>>,\n  client: BaseClient,\n): string {\n  // the object operation may contain user-provided data that requires encoding.\n  // for example, buffers must be encoded since the initial value will be represented as a JSON string.\n  // we can use ObjectMessage methods to encode the object operation.\n  const msg = ObjectMessage.fromValues(\n    // cast initialValue to ObjectOperation here, even though it may lack some properties\n    // that are usually present on ObjectOperation.\n    // this ObjectMessage instance is only used to get the encoded body,\n    // so it's ok for the operation field to be incomplete in this context.\n    // doing the type assertion here avoids the need to define a separate ObjectMessage\n    // type that supports a fully optional ObjectOperation.\n    { operation: operation as ObjectOperation<ObjectData> },\n    client.Utils,\n    client.MessageEncoding,\n  );\n  const wireMsg = msg.encode(client);\n\n  // get the encoded operation that is safe to be sent over the wire as a JSON string.\n  const { operation: encodedOperation } = wireMsg.encodeForWire(client.Utils.Format.json);\n\n  // finally, initialValue is the JSON string representation of the encoded operation.\n  return JSON.stringify(encodedOperation);\n}\n\nfunction strMsg(msg: any, className: string) {\n  let result = '[' + className;\n\n  for (const attr in msg) {\n    if (msg[attr] === undefined || attr === '_utils' || attr === '_messageEncoding') {\n      continue;\n    }\n\n    if (attr === 'operation' || attr === 'object' || attr === 'extras') {\n      result += `; ${attr}=${JSON.stringify(msg[attr])}`;\n    } else {\n      result += `; ${attr}=${msg[attr]}`;\n    }\n  }\n\n  result += ']';\n  return result;\n}\n\n/**\n * Deep copy public properties of an object message, using `JSON.parse(JSON.stringify(object))` for nested object fields like `operation` and `object`.\n *\n * Important: Buffer instances are not copied correctly using `JSON.parse(JSON.stringify(object))`, as they lose their type and become plain objects.\n * If you need access to the original Buffer values, use the original message instance instead.\n */\n\nfunction copyMsg(\n  msg: Utils.Properties<ObjectMessage | WireObjectMessage>,\n): Utils.Properties<ObjectMessage | WireObjectMessage> {\n  const result: Utils.Properties<ObjectMessage | WireObjectMessage> = {\n    id: msg.id,\n    clientId: msg.clientId,\n    connectionId: msg.connectionId,\n    timestamp: msg.timestamp,\n    serial: msg.serial,\n    serialTimestamp: msg.serialTimestamp,\n    siteCode: msg.siteCode,\n  };\n\n  if (msg.operation) {\n    result.operation = JSON.parse(JSON.stringify(msg.operation));\n  }\n  if (msg.object) {\n    result.object = JSON.parse(JSON.stringify(msg.object));\n  }\n  if (msg.extras) {\n    result.extras = JSON.parse(JSON.stringify(msg.extras));\n  }\n\n  return result;\n}\n\n/**\n * A decoded {@link WireObjectMessage} message\n * @spec OM1\n * @internal\n */\nexport class ObjectMessage {\n  id?: string; // OM2a\n  clientId?: string; // OM2b\n  connectionId?: string; // OM2c\n  extras?: any; // OM2d\n  timestamp?: number; // OM2e\n  /**\n   * Describes an operation to be applied to an object.\n   *\n   * Mutually exclusive with the `object` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT`.\n   */\n  operation?: ObjectOperation<ObjectData>; // OM2f\n  /**\n   * Describes the instantaneous state of an object.\n   *\n   * Mutually exclusive with the `operation` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT_SYNC`.\n   */\n  object?: ObjectState<ObjectData>; // OM2g\n  /** An opaque string that uniquely identifies this object message. */\n  serial?: string; // OM2h\n  /** A timestamp from the {@link serial} field. */\n  serialTimestamp?: number; // OM2j\n  /** An opaque string used as a key to update the map of serial values on an object. */\n  siteCode?: string; // OM2i\n\n  constructor(\n    private _utils: typeof Utils,\n    private _messageEncoding: typeof MessageEncoding,\n  ) {}\n\n  static fromValues(\n    values: Utils.Properties<ObjectMessage>,\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): ObjectMessage {\n    return Object.assign(new ObjectMessage(utils, messageEncoding), values);\n  }\n\n  static fromValuesArray(\n    values: Utils.Properties<ObjectMessage>[],\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): ObjectMessage[] {\n    return values.map((x) => ObjectMessage.fromValues(x, utils, messageEncoding));\n  }\n\n  /**\n   * Protocol agnostic encoding of this ObjectMessage. Returns a new {@link WireObjectMessage} instance.\n   *\n   * Uses encoding functions from regular `Message` processing.\n   *\n   * @spec OM4\n   */\n  encode(client: BaseClient): WireObjectMessage {\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data: ObjectData) => {\n      const encodedObjectData: WireObjectData = { objectId: data.objectId };\n\n      if (client.Platform.BufferUtils.isBuffer(data.value)) {\n        // bytes encoding happens later when WireObjectMessage is encoded for wire transmission\n        encodedObjectData.bytes = data.value;\n      } else if (typeof data.value === 'string') {\n        encodedObjectData.string = data.value; // OD4c4, OD4d4\n      } else if (typeof data.value === 'boolean') {\n        encodedObjectData.boolean = data.value; // OD4c1, OD4d1\n      } else if (typeof data.value === 'number') {\n        encodedObjectData.number = data.value; // OD4c3, OD4d3\n      } else if (typeof data.value === 'object' && data.value !== null) {\n        // OD4c5, OD4d5\n        encodedObjectData.json = JSON.stringify(data.value);\n      }\n\n      return encodedObjectData;\n    };\n\n    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);\n  }\n\n  toString(): string {\n    return strMsg(this, 'ObjectMessage');\n  }\n}\n\n/**\n * An individual object message to be sent or received via the Ably Realtime service.\n * @spec OM1\n * @internal\n */\nexport class WireObjectMessage {\n  id?: string; // OM2a\n  clientId?: string; // OM2b\n  connectionId?: string; // OM2c\n  extras?: any; // OM2d\n  timestamp?: number; // OM2e\n  /**\n   * Describes an operation to be applied to an object.\n   *\n   * Mutually exclusive with the `object` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT`.\n   */\n  operation?: ObjectOperation<WireObjectData>; // OM2f\n  /**\n   * Describes the instantaneous state of an object.\n   *\n   * Mutually exclusive with the `operation` field. This field is only set on object messages if the `action` field of the `ProtocolMessage` encapsulating it is `OBJECT_SYNC`.\n   */\n  object?: ObjectState<WireObjectData>; // OM2g\n  /** An opaque string that uniquely identifies this object message. */\n  serial?: string; // OM2h\n  /** A timestamp from the {@link serial} field. */\n  serialTimestamp?: number; // OM2j\n  /** An opaque string used as a key to update the map of serial values on an object. */\n  siteCode?: string; // OM2i\n\n  constructor(\n    private _utils: typeof Utils,\n    private _messageEncoding: typeof MessageEncoding,\n  ) {}\n\n  static fromValues(\n    values: Utils.Properties<WireObjectMessage>,\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): WireObjectMessage {\n    return Object.assign(new WireObjectMessage(utils, messageEncoding), values);\n  }\n\n  static fromValuesArray(\n    values: Utils.Properties<WireObjectMessage>[],\n    utils: typeof Utils,\n    messageEncoding: typeof MessageEncoding,\n  ): WireObjectMessage[] {\n    return values.map((x) => WireObjectMessage.fromValues(x, utils, messageEncoding));\n  }\n\n  /**\n   * Encodes WireObjectMessage for wire transmission. Does not mutate the provided WireObjectMessage.\n   *\n   * Uses encoding functions from regular `Message` processing.\n   */\n  encodeForWire(format: Utils.Format): WireObjectMessage {\n    const encodeObjectDataFn: EncodeObjectDataFunction = (data: WireObjectData) => {\n      if (data.bytes != null) {\n        // OD4c2, OD4d2\n        const result = this._messageEncoding.encodeDataForWire(data.bytes, null, format);\n        // no need to set the encoding\n        return { ...data, bytes: result.data };\n      }\n\n      return { ...data };\n    };\n\n    return encode(this, this._utils, this._messageEncoding, encodeObjectDataFn);\n  }\n\n  /**\n   * Decodes this WireObjectMessage and returns a new {@link ObjectMessage} instance.\n   *\n   * Format is used to decode the bytes value as it's implicitly encoded depending on the protocol used:\n   * - json: bytes are Base64-encoded string\n   * - msgpack: bytes have a binary representation and don't need to be decoded\n   *\n   * @spec OM5\n   */\n  decode(client: BaseClient, format: Utils.Format | undefined): ObjectMessage {\n    // deep copy the message to avoid mutating the original one.\n    // buffer values won't be correctly copied, so we will need to use the original message when decoding.\n    const result = Object.assign(new ObjectMessage(this._utils, this._messageEncoding), copyMsg(this));\n\n    try {\n      // decode \"object\" field\n      if (this.object?.map?.entries) {\n        result.object!.map!.entries = this._decodeMapEntries(this.object.map.entries, client, format);\n      }\n\n      if (this.object?.createOp?.map?.entries) {\n        result.object!.createOp!.map!.entries = this._decodeMapEntries(\n          this.object.createOp.map.entries,\n          client,\n          format,\n        );\n      }\n\n      if (this.object?.createOp?.mapOp?.data) {\n        result.object!.createOp!.mapOp!.data = this._decodeObjectData(this.object.createOp.mapOp.data, client, format);\n      }\n\n      // decode \"operation\" field\n      if (this.operation?.map?.entries) {\n        result.operation!.map!.entries = this._decodeMapEntries(this.operation.map.entries, client, format);\n      }\n\n      if (this.operation?.mapOp?.data) {\n        result.operation!.mapOp!.data = this._decodeObjectData(this.operation.mapOp.data, client, format);\n      }\n    } catch (error) {\n      client.Logger.logAction(\n        client.logger,\n        client.Logger.LOG_ERROR,\n        'WireObjectMessage.decode()',\n        this._utils.inspectError(error),\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Overload toJSON() to intercept JSON.stringify().\n   *\n   * This will prepare the message to be transmitted over the wire to Ably.\n   * It will encode the data payload according to the wire protocol used on the client.\n   */\n  toJSON() {\n    // we can infer the format used by client by inspecting with what arguments this method was called.\n    // if JSON protocol is being used, the JSON.stringify() will be called and this toJSON() method will have a non-empty arguments list.\n    // MSGPack protocol implementation also calls toJSON(), but with an empty arguments list.\n    const format = arguments.length > 0 ? this._utils.Format.json : this._utils.Format.msgpack;\n    const { _utils, _messageEncoding, ...publicProps } = this.encodeForWire(format);\n    return publicProps;\n  }\n\n  toString(): string {\n    return strMsg(this, 'WireObjectMessage');\n  }\n\n  /** @spec OM3 */\n  getMessageSize(): number {\n    let size = 0;\n\n    // OM3a\n    size += this.clientId?.length ?? 0; // OM3f\n    if (this.operation) {\n      size += this._getObjectOperationSize(this.operation); // OM3b\n    }\n    if (this.object) {\n      size += this._getObjectStateSize(this.object); // OM3c\n    }\n    if (this.extras) {\n      size += JSON.stringify(this.extras).length; // OM3d\n    }\n\n    return size;\n  }\n\n  /** @spec OOP4 */\n  private _getObjectOperationSize(operation: ObjectOperation<WireObjectData>): number {\n    let size = 0;\n\n    // OOP4a\n    if (operation.mapOp) {\n      size += this._getMapOpSize(operation.mapOp); // OOP4b\n    }\n    if (operation.counterOp) {\n      size += this._getCounterOpSize(operation.counterOp); // OOP4c\n    }\n    if (operation.map) {\n      size += this._getObjectMapSize(operation.map); // OOP4d\n    }\n    if (operation.counter) {\n      size += this._getObjectCounterSize(operation.counter); // OOP4e\n    }\n\n    return size;\n  }\n\n  /** @spec OST3 */\n  private _getObjectStateSize(obj: ObjectState<WireObjectData>): number {\n    let size = 0;\n\n    // OST3a\n    if (obj.map) {\n      size += this._getObjectMapSize(obj.map); // OST3b\n    }\n    if (obj.counter) {\n      size += this._getObjectCounterSize(obj.counter); // OST3c\n    }\n    if (obj.createOp) {\n      size += this._getObjectOperationSize(obj.createOp); // OST3d\n    }\n\n    return size;\n  }\n\n  /** @spec OMP4 */\n  private _getObjectMapSize(map: ObjectsMap<WireObjectData>): number {\n    let size = 0;\n\n    // OMP4a\n    Object.entries(map.entries ?? {}).forEach(([key, entry]) => {\n      size += key?.length ?? 0; // OMP4a1\n      if (entry) {\n        size += this._getMapEntrySize(entry); // OMP4a2\n      }\n    });\n\n    return size;\n  }\n\n  /** @spec OCN3 */\n  private _getObjectCounterSize(counter: ObjectsCounter): number {\n    // OCN3b\n    if (counter.count == null) {\n      return 0;\n    }\n\n    // OCN3a\n    return 8;\n  }\n\n  /** @spec OME3 */\n  private _getMapEntrySize(entry: ObjectsMapEntry<WireObjectData>): number {\n    let size = 0;\n\n    // OME3a\n    if (entry.data) {\n      size += this._getObjectDataSize(entry.data); // OME3b\n    }\n\n    return size;\n  }\n\n  /** @spec OMO3 */\n  private _getMapOpSize(mapOp: ObjectsMapOp<WireObjectData>): number {\n    let size = 0;\n\n    // OMO3a\n    size += mapOp.key?.length ?? 0; // OMO3d\n    if (mapOp.data) {\n      size += this._getObjectDataSize(mapOp.data); // OMO3b\n    }\n\n    return size;\n  }\n\n  /** @spec OCO3 */\n  private _getCounterOpSize(operation: ObjectsCounterOp): number {\n    // OCO3b\n    if (operation.amount == null) {\n      return 0;\n    }\n\n    // OCO3a\n    return 8;\n  }\n\n  /** @spec OD3 */\n  private _getObjectDataSize(data: WireObjectData): number {\n    let size = 0;\n\n    // OD3a\n    if (data.boolean != null) {\n      size += this._utils.dataSizeBytes(data.boolean); // OD3b\n    }\n    if (data.bytes != null) {\n      size += this._utils.dataSizeBytes(data.bytes); // OD3c\n    }\n    if (data.number != null) {\n      size += this._utils.dataSizeBytes(data.number); // OD3d\n    }\n    if (data.string != null) {\n      size += this._utils.dataSizeBytes(data.string); // OD3e\n    }\n    if (data.json != null) {\n      size += this._utils.dataSizeBytes(data.json);\n    }\n\n    return size;\n  }\n\n  private _decodeMapEntries(\n    mapEntries: Record<string, ObjectsMapEntry<WireObjectData>>,\n    client: BaseClient,\n    format: Utils.Format | undefined,\n  ): Record<string, ObjectsMapEntry<ObjectData>> {\n    return Object.entries(mapEntries).reduce(\n      (acc, v) => {\n        const [key, entry] = v;\n        const decodedData = entry.data ? this._decodeObjectData(entry.data, client, format) : undefined;\n        acc[key] = {\n          ...entry,\n          data: decodedData,\n        };\n        return acc;\n      },\n      {} as Record<string, ObjectsMapEntry<ObjectData>>,\n    );\n  }\n\n  /** @spec OD5 */\n  private _decodeObjectData(\n    objectData: WireObjectData,\n    client: BaseClient,\n    format: Utils.Format | undefined,\n  ): ObjectData {\n    try {\n      let decodedBytes: Bufferlike | undefined;\n      if (objectData.bytes != null) {\n        decodedBytes =\n          format === 'msgpack'\n            ? // OD5a1 - connection is using msgpack protocol, bytes are already a buffer\n              (objectData.bytes as Bufferlike)\n            : // OD5b2 - connection is using JSON protocol, Base64-decode bytes value\n              client.Platform.BufferUtils.base64Decode(String(objectData.bytes));\n      }\n\n      let decodedJson: JsonObject | JsonArray | undefined;\n      if (objectData.json != null) {\n        decodedJson = JSON.parse(objectData.json); // OD5a2, OD5b3\n      }\n\n      return {\n        objectId: objectData.objectId,\n        value: decodedBytes ?? decodedJson ?? objectData.boolean ?? objectData.number ?? objectData.string,\n      };\n    } catch (error) {\n      client.Logger.logAction(\n        client.logger,\n        client.Logger.LOG_ERROR,\n        'WireObjectMessage._decodeObjectData()',\n        this._utils.inspectError(error),\n      );\n      // object data decoding has failed, return the data as is.\n      return {\n        ...objectData,\n      } as ObjectData;\n    }\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type EventEmitter from 'common/lib/util/eventemitter';\nimport { ObjectData, ObjectMessage, ObjectOperation } from './objectmessage';\nimport { Objects } from './objects';\n\nexport enum LiveObjectSubscriptionEvent {\n  updated = 'updated',\n}\n\nexport interface LiveObjectData {\n  data: any;\n}\n\nexport interface LiveObjectUpdate {\n  update: any;\n  clientId?: string;\n  connectionId?: string;\n}\n\nexport interface LiveObjectUpdateNoop {\n  // have optional update field with undefined type so it's not possible to create a noop object with a meaningful update property.\n  update?: undefined;\n  noop: true;\n}\n\nexport interface SubscribeResponse {\n  unsubscribe(): void;\n}\n\nexport enum LiveObjectLifecycleEvent {\n  deleted = 'deleted',\n}\n\nexport type LiveObjectLifecycleEventCallback = () => void;\n\nexport interface OnLiveObjectLifecycleEventResponse {\n  off(): void;\n}\n\nexport abstract class LiveObject<\n  TData extends LiveObjectData = LiveObjectData,\n  TUpdate extends LiveObjectUpdate = LiveObjectUpdate,\n> {\n  protected _client: BaseClient;\n  protected _subscriptions: EventEmitter;\n  protected _lifecycleEvents: EventEmitter;\n  protected _objectId: string;\n  /**\n   * Represents an aggregated value for an object, which combines the initial value for an object from the create operation,\n   * and all object operations applied to the object.\n   */\n  protected _dataRef: TData;\n  protected _siteTimeserials: Record<string, string>;\n  protected _createOperationIsMerged: boolean;\n  private _tombstone: boolean;\n  private _tombstonedAt: number | undefined;\n\n  protected constructor(\n    protected _objects: Objects,\n    objectId: string,\n  ) {\n    this._client = this._objects.getClient();\n    this._subscriptions = new this._client.EventEmitter(this._client.logger);\n    this._lifecycleEvents = new this._client.EventEmitter(this._client.logger);\n    this._objectId = objectId;\n    this._dataRef = this._getZeroValueData();\n    // use empty map of serials by default, so any future operation can be applied to this object\n    this._siteTimeserials = {};\n    this._createOperationIsMerged = false;\n    this._tombstone = false;\n  }\n\n  subscribe(listener: (update: TUpdate) => void): SubscribeResponse {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n\n    this._subscriptions.on(LiveObjectSubscriptionEvent.updated, listener);\n\n    const unsubscribe = () => {\n      this._subscriptions.off(LiveObjectSubscriptionEvent.updated, listener);\n    };\n\n    return { unsubscribe };\n  }\n\n  unsubscribe(listener: (update: TUpdate) => void): void {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n\n    // current implementation of the EventEmitter will remove all listeners if .off is called without arguments or with nullish arguments.\n    // or when called with just an event argument, it will remove all listeners for the event.\n    // thus we need to check that listener does actually exist before calling .off.\n    if (this._client.Utils.isNil(listener)) {\n      return;\n    }\n\n    this._subscriptions.off(LiveObjectSubscriptionEvent.updated, listener);\n  }\n\n  unsubscribeAll(): void {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n    this._subscriptions.off(LiveObjectSubscriptionEvent.updated);\n  }\n\n  on(event: LiveObjectLifecycleEvent, callback: LiveObjectLifecycleEventCallback): OnLiveObjectLifecycleEventResponse {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n    this._lifecycleEvents.on(event, callback);\n\n    const off = () => {\n      this._lifecycleEvents.off(event, callback);\n    };\n\n    return { off };\n  }\n\n  off(event: LiveObjectLifecycleEvent, callback: LiveObjectLifecycleEventCallback): void {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n\n    // prevent accidentally calling .off without any arguments on an EventEmitter and removing all callbacks\n    if (this._client.Utils.isNil(event) && this._client.Utils.isNil(callback)) {\n      return;\n    }\n\n    this._lifecycleEvents.off(event, callback);\n  }\n\n  offAll(): void {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n    this._lifecycleEvents.off();\n  }\n\n  /**\n   * @internal\n   */\n  getObjectId(): string {\n    return this._objectId;\n  }\n\n  /**\n   * Emits the {@link LiveObjectSubscriptionEvent.updated} event with provided update object if it isn't a noop.\n   *\n   * @internal\n   */\n  notifyUpdated(update: TUpdate | LiveObjectUpdateNoop): void {\n    // should not emit update event if update was noop\n    if ((update as LiveObjectUpdateNoop).noop) {\n      return;\n    }\n\n    this._subscriptions.emit(LiveObjectSubscriptionEvent.updated, update);\n  }\n\n  /**\n   * Clears the object's data, cancels any buffered operations and sets the tombstone flag to `true`.\n   *\n   * @internal\n   */\n  tombstone(objectMessage: ObjectMessage): TUpdate {\n    this._tombstone = true;\n    if (objectMessage.serialTimestamp != null) {\n      this._tombstonedAt = objectMessage.serialTimestamp;\n    } else {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MINOR,\n        'LiveObject.tombstone()',\n        `object has been tombstoned but no \"serialTimestamp\" found in the message, using local clock instead; objectId=${this.getObjectId()}`,\n      );\n      this._tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\n    }\n    const update = this.clearData();\n    update.clientId = objectMessage.clientId;\n    update.connectionId = objectMessage.connectionId;\n    this._lifecycleEvents.emit(LiveObjectLifecycleEvent.deleted);\n\n    return update;\n  }\n\n  /**\n   * @internal\n   */\n  isTombstoned(): boolean {\n    return this._tombstone;\n  }\n\n  /**\n   * @internal\n   */\n  tombstonedAt(): number | undefined {\n    return this._tombstonedAt;\n  }\n\n  /**\n   * @internal\n   */\n  clearData(): TUpdate {\n    const previousDataRef = this._dataRef;\n    this._dataRef = this._getZeroValueData();\n    return this._updateFromDataDiff(previousDataRef, this._dataRef);\n  }\n\n  /**\n   * Returns true if the given serial indicates that the operation to which it belongs should be applied to the object.\n   *\n   * An operation should be applied if its serial is strictly greater than the serial in the `siteTimeserials` map for the same site.\n   * If `siteTimeserials` map does not contain a serial for the same site, the operation should be applied.\n   */\n  protected _canApplyOperation(opSerial: string | undefined, opSiteCode: string | undefined): boolean {\n    if (!opSerial) {\n      throw new this._client.ErrorInfo(`Invalid serial: ${opSerial}`, 92000, 500);\n    }\n\n    if (!opSiteCode) {\n      throw new this._client.ErrorInfo(`Invalid site code: ${opSiteCode}`, 92000, 500);\n    }\n\n    const siteSerial = this._siteTimeserials[opSiteCode];\n    return !siteSerial || opSerial > siteSerial;\n  }\n\n  protected _applyObjectDelete(objectMessage: ObjectMessage): TUpdate {\n    return this.tombstone(objectMessage);\n  }\n\n  /**\n   * Apply object operation message on this LiveObject.\n   *\n   * @internal\n   */\n  abstract applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage): void;\n  /**\n   * Overrides internal data for this LiveObject with object state from the given object message.\n   * Provided object state should hold a valid data for current LiveObject, e.g. counter data for LiveCounter, map data for LiveMap.\n   *\n   * Object states are received during sync sequence, and sync sequence is a source of truth for the current state of the objects,\n   * so we can use the data received from the sync sequence directly and override any data values or site serials this LiveObject has\n   * without the need to merge them.\n   *\n   * Returns an update object that describes the changes applied based on the object's previous value.\n   *\n   * @internal\n   */\n  abstract overrideWithObjectState(objectMessage: ObjectMessage): TUpdate | LiveObjectUpdateNoop;\n  /**\n   * @internal\n   */\n  abstract onGCInterval(): void;\n\n  protected abstract _getZeroValueData(): TData;\n  /**\n   * Calculate the update object based on the current LiveObject data and incoming new data.\n   */\n  protected abstract _updateFromDataDiff(prevDataRef: TData, newDataRef: TData): TUpdate;\n  /**\n   * Merges the initial data from the create operation into the LiveObject.\n   *\n   * Client SDKs do not need to keep around the object operation that created the object,\n   * so we can merge the initial data the first time we receive it for the object,\n   * and work with aggregated value after that.\n   *\n   * This saves us from needing to merge the initial value with operations applied to\n   * the object every time the object is read.\n   */\n  protected abstract _mergeInitialDataFromCreateOperation(\n    objectOperation: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): TUpdate;\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type Platform from 'common/platform';\n\nexport type LiveObjectType = 'map' | 'counter';\n\n/**\n * Represents a parsed object id.\n *\n * @internal\n */\nexport class ObjectId {\n  private constructor(\n    readonly type: LiveObjectType,\n    readonly hash: string,\n    readonly msTimestamp: number,\n  ) {}\n\n  static fromInitialValue(\n    platform: typeof Platform,\n    objectType: LiveObjectType,\n    initialValue: string,\n    nonce: string,\n    msTimestamp: number,\n  ): ObjectId {\n    const valueForHashBuffer = platform.BufferUtils.concat([\n      platform.BufferUtils.utf8Encode(initialValue),\n      platform.BufferUtils.utf8Encode(':'),\n      platform.BufferUtils.utf8Encode(nonce),\n    ]);\n    const hashBuffer = platform.BufferUtils.sha256(valueForHashBuffer);\n    const hash = platform.BufferUtils.base64UrlEncode(hashBuffer);\n\n    return new ObjectId(objectType, hash, msTimestamp);\n  }\n\n  /**\n   * Create ObjectId instance from hashed object id string.\n   */\n  static fromString(client: BaseClient, objectId: string | null | undefined): ObjectId {\n    if (client.Utils.isNil(objectId)) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    // RTO6b1\n    const [type, rest] = objectId.split(':');\n    if (!type || !rest) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    if (!['map', 'counter'].includes(type)) {\n      throw new client.ErrorInfo(`Invalid object type in object id: ${objectId}`, 92000, 500);\n    }\n\n    const [hash, msTimestamp] = rest.split('@');\n    if (!hash || !msTimestamp) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    if (!Number.isInteger(Number.parseInt(msTimestamp))) {\n      throw new client.ErrorInfo('Invalid object id string', 92000, 500);\n    }\n\n    return new ObjectId(type as LiveObjectType, hash, Number.parseInt(msTimestamp));\n  }\n\n  toString(): string {\n    return `${this.type}:${this.hash}@${this.msTimestamp}`;\n  }\n}\n", "import { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\nimport { ObjectId } from './objectid';\nimport {\n  createInitialValueJSONString,\n  ObjectData,\n  ObjectMessage,\n  ObjectOperation,\n  ObjectOperationAction,\n  ObjectsCounterOp,\n} from './objectmessage';\nimport { Objects } from './objects';\n\nexport interface LiveCounterData extends LiveObjectData {\n  data: number; // RTLC3\n}\n\nexport interface LiveCounterUpdate extends LiveObjectUpdate {\n  update: { amount: number };\n}\n\n/** @spec RTLC1, RTLC2 */\nexport class LiveCounter extends LiveObject<LiveCounterData, LiveCounterUpdate> {\n  /**\n   * Returns a {@link LiveCounter} instance with a 0 value.\n   *\n   * @internal\n   * @spec RTLC4\n   */\n  static zeroValue(objects: Objects, objectId: string): LiveCounter {\n    return new LiveCounter(objects, objectId);\n  }\n\n  /**\n   * Returns a {@link LiveCounter} instance based on the provided object state.\n   * The provided object state must hold a valid counter object data.\n   *\n   * @internal\n   */\n  static fromObjectState(objects: Objects, objectMessage: ObjectMessage): LiveCounter {\n    const obj = new LiveCounter(objects, objectMessage.object!.objectId);\n    obj.overrideWithObjectState(objectMessage);\n    return obj;\n  }\n\n  /**\n   * Returns a {@link LiveCounter} instance based on the provided COUNTER_CREATE object operation.\n   * The provided object operation must hold a valid counter object data.\n   *\n   * @internal\n   */\n  static fromObjectOperation(objects: Objects, objectMessage: ObjectMessage): LiveCounter {\n    const obj = new LiveCounter(objects, objectMessage.operation!.objectId);\n    obj._mergeInitialDataFromCreateOperation(objectMessage.operation!, objectMessage);\n    return obj;\n  }\n\n  /**\n   * @internal\n   */\n  static createCounterIncMessage(objects: Objects, objectId: string, amount: number): ObjectMessage {\n    const client = objects.getClient();\n\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\n      throw new client.ErrorInfo('Counter value increment should be a valid number', 40003, 400);\n    }\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          action: ObjectOperationAction.COUNTER_INC,\n          objectId,\n          counterOp: { amount },\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  /**\n   * @internal\n   */\n  static async createCounterCreateMessage(objects: Objects, count?: number): Promise<ObjectMessage> {\n    const client = objects.getClient();\n\n    if (count !== undefined && (typeof count !== 'number' || !Number.isFinite(count))) {\n      throw new client.ErrorInfo('Counter value should be a valid number', 40003, 400);\n    }\n\n    const initialValueOperation = LiveCounter.createInitialValueOperation(count);\n    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);\n    const nonce = client.Utils.cheapRandStr();\n    const msTimestamp = await client.getTimestamp(true);\n\n    const objectId = ObjectId.fromInitialValue(\n      client.Platform,\n      'counter',\n      initialValueJSONString,\n      nonce,\n      msTimestamp,\n    ).toString();\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          ...initialValueOperation,\n          action: ObjectOperationAction.COUNTER_CREATE,\n          objectId,\n          nonce,\n          initialValue: initialValueJSONString,\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  /**\n   * @internal\n   */\n  static createInitialValueOperation(count?: number): Pick<ObjectOperation<ObjectData>, 'counter'> {\n    return {\n      counter: {\n        count: count ?? 0,\n      },\n    };\n  }\n\n  /** @spec RTLC5 */\n  value(): number {\n    this._objects.throwIfInvalidAccessApiConfiguration(); // RTLC5a, RTLC5b\n    return this._dataRef.data; // RTLC5c\n  }\n\n  /**\n   * Send a COUNTER_INC operation to the realtime system to increment a value on this LiveCounter object.\n   *\n   * This does not modify the underlying data of this LiveCounter object. Instead, the change will be applied when\n   * the published COUNTER_INC operation is echoed back to the client and applied to the object following the regular\n   * operation application procedure.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\n   */\n  async increment(amount: number): Promise<void> {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    const msg = LiveCounter.createCounterIncMessage(this._objects, this.getObjectId(), amount);\n    return this._objects.publish([msg]);\n  }\n\n  /**\n   * An alias for calling {@link LiveCounter.increment | LiveCounter.increment(-amount)}\n   */\n  async decrement(amount: number): Promise<void> {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    // do an explicit type safety check here before negating the amount value,\n    // so we don't unintentionally change the type sent by a user\n    if (typeof amount !== 'number' || !Number.isFinite(amount)) {\n      throw new this._client.ErrorInfo('Counter value decrement should be a valid number', 40003, 400);\n    }\n\n    return this.increment(-amount);\n  }\n\n  /**\n   * @internal\n   */\n  applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage): void {\n    if (op.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    const opSerial = msg.serial!;\n    const opSiteCode = msg.siteCode!;\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveCounter.applyOperation()',\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return;\n    }\n    // should update stored site serial immediately. doesn't matter if we successfully apply the op,\n    // as it's important to mark that the op was processed by the object\n    this._siteTimeserials[opSiteCode] = opSerial;\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned so the operation cannot be applied\n      return;\n    }\n\n    let update: LiveCounterUpdate | LiveObjectUpdateNoop;\n    switch (op.action) {\n      case ObjectOperationAction.COUNTER_CREATE:\n        update = this._applyCounterCreate(op, msg);\n        break;\n\n      case ObjectOperationAction.COUNTER_INC:\n        if (this._client.Utils.isNil(op.counterOp)) {\n          this._throwNoPayloadError(op);\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\n          return;\n        } else {\n          update = this._applyCounterInc(op.counterOp, msg);\n        }\n        break;\n\n      case ObjectOperationAction.OBJECT_DELETE:\n        update = this._applyObjectDelete(msg);\n        break;\n\n      default:\n        throw new this._client.ErrorInfo(\n          `Invalid ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n    }\n\n    this.notifyUpdated(update);\n  }\n\n  /**\n   * @internal\n   * @spec RTLC6\n   */\n  overrideWithObjectState(objectMessage: ObjectMessage): LiveCounterUpdate | LiveObjectUpdateNoop {\n    const objectState = objectMessage.object;\n    if (objectState == null) {\n      throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`, 92000, 500);\n    }\n\n    if (objectState.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveCounter objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    if (!this._client.Utils.isNil(objectState.createOp)) {\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\n      if (objectState.createOp.objectId !== this.getObjectId()) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveCounter objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n\n      if (objectState.createOp.action !== ObjectOperationAction.COUNTER_CREATE) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveCounter objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n    }\n\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the operation.\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\n    this._siteTimeserials = objectState.siteTimeserials ?? {}; // RTLC6a\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\n      return { noop: true };\n    }\n\n    const previousDataRef = this._dataRef;\n    if (objectState.tombstone) {\n      // tombstone this object and ignore the data from the object state message\n      this.tombstone(objectMessage);\n    } else {\n      // override data for this object with data from the object state\n      this._createOperationIsMerged = false; // RTLC6b\n      this._dataRef = { data: objectState.counter?.count ?? 0 }; // RTLC6c\n      // RTLC6d\n      if (!this._client.Utils.isNil(objectState.createOp)) {\n        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);\n      }\n    }\n\n    // if object got tombstoned, the update object will include all data that got cleared.\n    // otherwise it is a diff between previous value and new value from object state.\n    const update = this._updateFromDataDiff(previousDataRef, this._dataRef);\n    update.clientId = objectMessage.clientId;\n    update.connectionId = objectMessage.connectionId;\n    return update;\n  }\n\n  /**\n   * @internal\n   */\n  onGCInterval(): void {\n    // nothing to GC for a counter object\n    return;\n  }\n\n  /** @spec RTLC4 */\n  protected _getZeroValueData(): LiveCounterData {\n    return { data: 0 };\n  }\n\n  protected _updateFromDataDiff(prevDataRef: LiveCounterData, newDataRef: LiveCounterData): LiveCounterUpdate {\n    const counterDiff = newDataRef.data - prevDataRef.data;\n    return { update: { amount: counterDiff } };\n  }\n\n  protected _mergeInitialDataFromCreateOperation(\n    objectOperation: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveCounterUpdate {\n    // if a counter object is missing for the COUNTER_CREATE op, the initial value is implicitly 0 in this case.\n    // note that it is intentional to SUM the incoming count from the create op.\n    // if we got here, it means that current counter instance is missing the initial value in its data reference,\n    // which we're going to add now.\n    this._dataRef.data += objectOperation.counter?.count ?? 0; // RTLC6d1\n    this._createOperationIsMerged = true; // RTLC6d2\n\n    return {\n      update: { amount: objectOperation.counter?.count ?? 0 },\n      clientId: msg.clientId,\n      connectionId: msg.connectionId,\n    };\n  }\n\n  private _throwNoPayloadError(op: ObjectOperation<ObjectData>): void {\n    throw new this._client.ErrorInfo(\n      `No payload found for ${op.action} op for LiveCounter objectId=${this.getObjectId()}`,\n      92000,\n      500,\n    );\n  }\n\n  private _applyCounterCreate(\n    op: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveCounterUpdate | LiveObjectUpdateNoop {\n    if (this._createOperationIsMerged) {\n      // There can't be two different create operation for the same object id, because the object id\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\n      // if we already merged it once.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveCounter._applyCounterCreate()',\n        `skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    return this._mergeInitialDataFromCreateOperation(op, msg);\n  }\n\n  private _applyCounterInc(op: ObjectsCounterOp, msg: ObjectMessage): LiveCounterUpdate {\n    this._dataRef.data += op.amount;\n    return { update: { amount: op.amount }, clientId: msg.clientId, connectionId: msg.connectionId };\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport { BatchContext } from './batchcontext';\nimport { LiveCounter } from './livecounter';\nimport { Objects } from './objects';\n\nexport class BatchContextLiveCounter {\n  private _client: BaseClient;\n\n  constructor(\n    private _batchContext: BatchContext,\n    private _objects: Objects,\n    private _counter: LiveCounter,\n  ) {\n    this._client = this._objects.getClient();\n  }\n\n  value(): number {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n    this._batchContext.throwIfClosed();\n    return this._counter.value();\n  }\n\n  increment(amount: number): void {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    this._batchContext.throwIfClosed();\n    const msg = LiveCounter.createCounterIncMessage(this._objects, this._counter.getObjectId(), amount);\n    this._batchContext.queueMessage(msg);\n  }\n\n  decrement(amount: number): void {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    this._batchContext.throwIfClosed();\n    // do an explicit type safety check here before negating the amount value,\n    // so we don't unintentionally change the type sent by a user\n    if (typeof amount !== 'number') {\n      throw new this._client.ErrorInfo('Counter value decrement should be a number', 40003, 400);\n    }\n\n    this.increment(-amount);\n  }\n}\n", "var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "import { dequal } from 'dequal';\n\nimport type { Bufferlike } from 'common/platform';\nimport type * as API from '../../../ably';\nimport { LiveObject, LiveObjectData, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\nimport { ObjectId } from './objectid';\nimport {\n  createInitialValueJSONString,\n  ObjectData,\n  ObjectMessage,\n  ObjectOperation,\n  ObjectOperationAction,\n  ObjectsMapEntry,\n  ObjectsMapOp,\n  ObjectsMapSemantics,\n  PrimitiveObjectValue,\n} from './objectmessage';\nimport { Objects } from './objects';\n\nexport interface ObjectIdObjectData {\n  /** A reference to another object, used to support composable object structures. */\n  objectId: string;\n}\n\nexport interface ValueObjectData {\n  /** A decoded leaf value from {@link WireObjectData}. */\n  value: string | number | boolean | Bufferlike | API.JsonArray | API.JsonObject;\n}\n\nexport type LiveMapObjectData = ObjectIdObjectData | ValueObjectData;\n\nexport interface LiveMapEntry {\n  tombstone: boolean;\n  tombstonedAt: number | undefined;\n  timeserial: string | undefined;\n  data: LiveMapObjectData | undefined;\n}\n\nexport interface LiveMapData extends LiveObjectData {\n  data: Map<string, LiveMapEntry>; // RTLM3\n}\n\nexport interface LiveMapUpdate<T extends API.LiveMapType> extends LiveObjectUpdate {\n  update: { [keyName in keyof T & string]?: 'updated' | 'removed' };\n}\n\n/** @spec RTLM1, RTLM2 */\nexport class LiveMap<T extends API.LiveMapType> extends LiveObject<LiveMapData, LiveMapUpdate<T>> {\n  constructor(\n    objects: Objects,\n    private _semantics: ObjectsMapSemantics,\n    objectId: string,\n  ) {\n    super(objects, objectId);\n  }\n\n  /**\n   * Returns a {@link LiveMap} instance with an empty map data.\n   *\n   * @internal\n   * @spec RTLM4\n   */\n  static zeroValue<T extends API.LiveMapType>(objects: Objects, objectId: string): LiveMap<T> {\n    return new LiveMap<T>(objects, ObjectsMapSemantics.LWW, objectId);\n  }\n\n  /**\n   * Returns a {@link LiveMap} instance based on the provided object state.\n   * The provided object state must hold a valid map object data.\n   *\n   * @internal\n   */\n  static fromObjectState<T extends API.LiveMapType>(objects: Objects, objectMessage: ObjectMessage): LiveMap<T> {\n    const obj = new LiveMap<T>(objects, objectMessage.object!.map!.semantics!, objectMessage.object!.objectId);\n    obj.overrideWithObjectState(objectMessage);\n    return obj;\n  }\n\n  /**\n   * Returns a {@link LiveMap} instance based on the provided MAP_CREATE object operation.\n   * The provided object operation must hold a valid map object data.\n   *\n   * @internal\n   */\n  static fromObjectOperation<T extends API.LiveMapType>(objects: Objects, objectMessage: ObjectMessage): LiveMap<T> {\n    const obj = new LiveMap<T>(objects, objectMessage.operation!.map?.semantics!, objectMessage.operation!.objectId);\n    obj._mergeInitialDataFromCreateOperation(objectMessage.operation!, objectMessage);\n    return obj;\n  }\n\n  /**\n   * @internal\n   */\n  static createMapSetMessage<TKey extends keyof API.LiveMapType & string>(\n    objects: Objects,\n    objectId: string,\n    key: TKey,\n    value: API.LiveMapType[TKey],\n  ): ObjectMessage {\n    const client = objects.getClient();\n\n    LiveMap.validateKeyValue(objects, key, value);\n\n    let objectData: LiveMapObjectData;\n    if (value instanceof LiveObject) {\n      const typedObjectData: ObjectIdObjectData = { objectId: value.getObjectId() };\n      objectData = typedObjectData;\n    } else {\n      const typedObjectData: ValueObjectData = { value: value as PrimitiveObjectValue };\n      objectData = typedObjectData;\n    }\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          action: ObjectOperationAction.MAP_SET,\n          objectId,\n          mapOp: {\n            key,\n            data: objectData,\n          },\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  /**\n   * @internal\n   */\n  static createMapRemoveMessage<TKey extends keyof API.LiveMapType & string>(\n    objects: Objects,\n    objectId: string,\n    key: TKey,\n  ): ObjectMessage {\n    const client = objects.getClient();\n\n    if (typeof key !== 'string') {\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\n    }\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          action: ObjectOperationAction.MAP_REMOVE,\n          objectId,\n          mapOp: { key },\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  /**\n   * @internal\n   */\n  static validateKeyValue<TKey extends keyof API.LiveMapType & string>(\n    objects: Objects,\n    key: TKey,\n    value: API.LiveMapType[TKey],\n  ): void {\n    const client = objects.getClient();\n\n    if (typeof key !== 'string') {\n      throw new client.ErrorInfo('Map key should be string', 40003, 400);\n    }\n\n    if (\n      value === null ||\n      (typeof value !== 'string' &&\n        typeof value !== 'number' &&\n        typeof value !== 'boolean' &&\n        typeof value !== 'object')\n    ) {\n      throw new client.ErrorInfo('Map value data type is unsupported', 40013, 400); // OD4a\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static async createMapCreateMessage(objects: Objects, entries?: API.LiveMapType): Promise<ObjectMessage> {\n    const client = objects.getClient();\n\n    if (entries !== undefined && (entries === null || typeof entries !== 'object')) {\n      throw new client.ErrorInfo('Map entries should be a key-value object', 40003, 400);\n    }\n\n    Object.entries(entries ?? {}).forEach(([key, value]) => LiveMap.validateKeyValue(objects, key, value));\n\n    const initialValueOperation = LiveMap.createInitialValueOperation(entries);\n    const initialValueJSONString = createInitialValueJSONString(initialValueOperation, client);\n    const nonce = client.Utils.cheapRandStr();\n    const msTimestamp = await client.getTimestamp(true);\n\n    const objectId = ObjectId.fromInitialValue(\n      client.Platform,\n      'map',\n      initialValueJSONString,\n      nonce,\n      msTimestamp,\n    ).toString();\n\n    const msg = ObjectMessage.fromValues(\n      {\n        operation: {\n          ...initialValueOperation,\n          action: ObjectOperationAction.MAP_CREATE,\n          objectId,\n          nonce,\n          initialValue: initialValueJSONString,\n        } as ObjectOperation<ObjectData>,\n      },\n      client.Utils,\n      client.MessageEncoding,\n    );\n\n    return msg;\n  }\n\n  /**\n   * @internal\n   */\n  static createInitialValueOperation(entries?: API.LiveMapType): Pick<ObjectOperation<ObjectData>, 'map'> {\n    const mapEntries: Record<string, ObjectsMapEntry<ObjectData>> = {};\n\n    Object.entries(entries ?? {}).forEach(([key, value]) => {\n      let objectData: LiveMapObjectData;\n      if (value instanceof LiveObject) {\n        const typedObjectData: ObjectIdObjectData = { objectId: value.getObjectId() };\n        objectData = typedObjectData;\n      } else {\n        const typedObjectData: ValueObjectData = { value: value as PrimitiveObjectValue };\n        objectData = typedObjectData;\n      }\n\n      mapEntries[key] = {\n        data: objectData,\n      };\n    });\n\n    return {\n      map: {\n        semantics: ObjectsMapSemantics.LWW,\n        entries: mapEntries,\n      },\n    };\n  }\n\n  /**\n   * Returns the value associated with the specified key in the underlying Map object.\n   *\n   * - If this map object is tombstoned (deleted), `undefined` is returned.\n   * - If no entry is associated with the specified key, `undefined` is returned.\n   * - If map entry is tombstoned (deleted), `undefined` is returned.\n   * - If the value associated with the provided key is an objectId string of another LiveObject, a reference to that LiveObject\n   * is returned, provided it exists in the local pool and is not tombstoned. Otherwise, `undefined` is returned.\n   * - If the value is not an objectId, then that value is returned.\n   *\n   * @spec RTLM5, RTLM5a\n   */\n  // force the key to be of type string as we only allow strings as key in a map\n  get<TKey extends keyof T & string>(key: TKey): T[TKey] | undefined {\n    this._objects.throwIfInvalidAccessApiConfiguration(); // RTLM5b, RTLM5c\n\n    if (this.isTombstoned()) {\n      return undefined as T[TKey];\n    }\n\n    const element = this._dataRef.data.get(key);\n\n    // RTLM5d1\n    if (element === undefined) {\n      return undefined as T[TKey];\n    }\n\n    // RTLM5d2a\n    if (element.tombstone === true) {\n      return undefined as T[TKey];\n    }\n\n    // data always exists for non-tombstoned elements\n    return this._getResolvedValueFromObjectData(element.data!) as T[TKey];\n  }\n\n  size(): number {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n\n    let size = 0;\n    for (const value of this._dataRef.data.values()) {\n      if (this._isMapEntryTombstoned(value)) {\n        // should not count tombstoned entries\n        continue;\n      }\n\n      size++;\n    }\n\n    return size;\n  }\n\n  *entries<TKey extends keyof T & string>(): IterableIterator<[TKey, T[TKey]]> {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n\n    for (const [key, entry] of this._dataRef.data.entries()) {\n      if (this._isMapEntryTombstoned(entry)) {\n        // do not return tombstoned entries\n        continue;\n      }\n\n      // data always exists for non-tombstoned elements\n      const value = this._getResolvedValueFromObjectData(entry.data!) as T[TKey];\n      yield [key as TKey, value];\n    }\n  }\n\n  *keys<TKey extends keyof T & string>(): IterableIterator<TKey> {\n    for (const [key] of this.entries<TKey>()) {\n      yield key;\n    }\n  }\n\n  *values<TKey extends keyof T & string>(): IterableIterator<T[TKey]> {\n    for (const [_, value] of this.entries<TKey>()) {\n      yield value;\n    }\n  }\n\n  /**\n   * Send a MAP_SET operation to the realtime system to set a key on this LiveMap object to a specified value.\n   *\n   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when\n   * the published MAP_SET operation is echoed back to the client and applied to the object following the regular\n   * operation application procedure.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\n   */\n  async set<TKey extends keyof T & string>(key: TKey, value: T[TKey]): Promise<void> {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    const msg = LiveMap.createMapSetMessage(this._objects, this.getObjectId(), key, value);\n    return this._objects.publish([msg]);\n  }\n\n  /**\n   * Send a MAP_REMOVE operation to the realtime system to tombstone a key on this LiveMap object.\n   *\n   * This does not modify the underlying data of this LiveMap object. Instead, the change will be applied when\n   * the published MAP_REMOVE operation is echoed back to the client and applied to the object following the regular\n   * operation application procedure.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message.\n   */\n  async remove<TKey extends keyof T & string>(key: TKey): Promise<void> {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    const msg = LiveMap.createMapRemoveMessage(this._objects, this.getObjectId(), key);\n    return this._objects.publish([msg]);\n  }\n\n  /**\n   * @internal\n   */\n  applyOperation(op: ObjectOperation<ObjectData>, msg: ObjectMessage): void {\n    if (op.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Cannot apply object operation with objectId=${op.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    const opSerial = msg.serial!;\n    const opSiteCode = msg.siteCode!;\n    if (!this._canApplyOperation(opSerial, opSiteCode)) {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap.applyOperation()',\n        `skipping ${op.action} op: op serial ${opSerial.toString()} <= site serial ${this._siteTimeserials[opSiteCode]?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return;\n    }\n    // should update stored site serial immediately. doesn't matter if we successfully apply the op,\n    // as it's important to mark that the op was processed by the object\n    this._siteTimeserials[opSiteCode] = opSerial;\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned so the operation cannot be applied\n      return;\n    }\n\n    let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\n    switch (op.action) {\n      case ObjectOperationAction.MAP_CREATE:\n        update = this._applyMapCreate(op, msg);\n        break;\n\n      case ObjectOperationAction.MAP_SET:\n        if (this._client.Utils.isNil(op.mapOp)) {\n          this._throwNoPayloadError(op);\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\n          return;\n        } else {\n          update = this._applyMapSet(op.mapOp, opSerial, msg);\n        }\n        break;\n\n      case ObjectOperationAction.MAP_REMOVE:\n        if (this._client.Utils.isNil(op.mapOp)) {\n          this._throwNoPayloadError(op);\n          // leave an explicit return here, so that TS knows that update object is always set after the switch statement.\n          return;\n        } else {\n          update = this._applyMapRemove(op.mapOp, opSerial, msg.serialTimestamp, msg);\n        }\n        break;\n\n      case ObjectOperationAction.OBJECT_DELETE:\n        update = this._applyObjectDelete(msg);\n        break;\n\n      default:\n        throw new this._client.ErrorInfo(\n          `Invalid ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n    }\n\n    this.notifyUpdated(update);\n  }\n\n  /**\n   * @internal\n   * @spec RTLM6\n   */\n  overrideWithObjectState(objectMessage: ObjectMessage): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    const objectState = objectMessage.object;\n    if (objectState == null) {\n      throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`, 92000, 500);\n    }\n\n    if (objectState.objectId !== this.getObjectId()) {\n      throw new this._client.ErrorInfo(\n        `Invalid object state: object state objectId=${objectState.objectId}; LiveMap objectId=${this.getObjectId()}`,\n        92000,\n        500,\n      );\n    }\n\n    if (objectState.map?.semantics !== this._semantics) {\n      throw new this._client.ErrorInfo(\n        `Invalid object state: object state map semantics=${objectState.map?.semantics}; LiveMap semantics=${this._semantics}`,\n        92000,\n        500,\n      );\n    }\n\n    if (!this._client.Utils.isNil(objectState.createOp)) {\n      // it is expected that create operation can be missing in the object state, so only validate it when it exists\n      if (objectState.createOp.objectId !== this.getObjectId()) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp objectId=${objectState.createOp?.objectId}; LiveMap objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n\n      if (objectState.createOp.action !== ObjectOperationAction.MAP_CREATE) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp action=${objectState.createOp?.action}; LiveMap objectId=${this.getObjectId()}`,\n          92000,\n          500,\n        );\n      }\n\n      if (objectState.createOp.map?.semantics !== this._semantics) {\n        throw new this._client.ErrorInfo(\n          `Invalid object state: object state createOp map semantics=${objectState.createOp.map?.semantics}; LiveMap semantics=${this._semantics}`,\n          92000,\n          500,\n        );\n      }\n    }\n\n    // object's site serials are still updated even if it is tombstoned, so always use the site serials received from the op.\n    // should default to empty map if site serials do not exist on the object state, so that any future operation may be applied to this object.\n    this._siteTimeserials = objectState.siteTimeserials ?? {}; // RTLM6a\n\n    if (this.isTombstoned()) {\n      // this object is tombstoned. this is a terminal state which can't be overridden. skip the rest of object state message processing\n      return { noop: true };\n    }\n\n    const previousDataRef = this._dataRef;\n    if (objectState.tombstone) {\n      // tombstone this object and ignore the data from the object state message\n      this.tombstone(objectMessage);\n    } else {\n      // override data for this object with data from the object state\n      this._createOperationIsMerged = false; // RTLM6b\n      this._dataRef = this._liveMapDataFromMapEntries(objectState.map?.entries ?? {}); // RTLM6c\n      // RTLM6d\n      if (!this._client.Utils.isNil(objectState.createOp)) {\n        this._mergeInitialDataFromCreateOperation(objectState.createOp, objectMessage);\n      }\n    }\n\n    // if object got tombstoned, the update object will include all data that got cleared.\n    // otherwise it is a diff between previous value and new value from object state.\n    const update = this._updateFromDataDiff(previousDataRef, this._dataRef);\n    update.clientId = objectMessage.clientId;\n    update.connectionId = objectMessage.connectionId;\n    return update;\n  }\n\n  /**\n   * @internal\n   */\n  onGCInterval(): void {\n    // should remove any tombstoned entries from the underlying map data that have exceeded the GC grace period\n\n    const keysToDelete: string[] = [];\n    for (const [key, value] of this._dataRef.data.entries()) {\n      if (value.tombstone === true && Date.now() - value.tombstonedAt! >= this._objects.gcGracePeriod) {\n        keysToDelete.push(key);\n      }\n    }\n\n    keysToDelete.forEach((x) => this._dataRef.data.delete(x));\n  }\n\n  /** @spec RTLM4 */\n  protected _getZeroValueData(): LiveMapData {\n    return { data: new Map<string, LiveMapEntry>() };\n  }\n\n  protected _updateFromDataDiff(prevDataRef: LiveMapData, newDataRef: LiveMapData): LiveMapUpdate<T> {\n    const update: LiveMapUpdate<T> = { update: {} };\n\n    for (const [key, currentEntry] of prevDataRef.data.entries()) {\n      const typedKey: keyof T & string = key;\n      // any non-tombstoned properties that exist on a current map, but not in the new data - got removed\n      if (currentEntry.tombstone === false && !newDataRef.data.has(typedKey)) {\n        update.update[typedKey] = 'removed';\n      }\n    }\n\n    for (const [key, newEntry] of newDataRef.data.entries()) {\n      const typedKey: keyof T & string = key;\n      if (!prevDataRef.data.has(typedKey)) {\n        // if property does not exist in the current map, but new data has it as a non-tombstoned property - got updated\n        if (newEntry.tombstone === false) {\n          update.update[typedKey] = 'updated';\n          continue;\n        }\n\n        // otherwise, if new data has this prop tombstoned - do nothing, as property didn't exist anyway\n        if (newEntry.tombstone === true) {\n          continue;\n        }\n      }\n\n      // properties that exist both in current and new map data need to have their values compared to decide on the update type\n      const currentEntry = prevDataRef.data.get(typedKey)!;\n\n      // compare tombstones first\n      if (currentEntry.tombstone === true && newEntry.tombstone === false) {\n        // current prop is tombstoned, but new is not. it means prop was updated to a meaningful value\n        update.update[typedKey] = 'updated';\n        continue;\n      }\n      if (currentEntry.tombstone === false && newEntry.tombstone === true) {\n        // current prop is not tombstoned, but new is. it means prop was removed\n        update.update[typedKey] = 'removed';\n        continue;\n      }\n      if (currentEntry.tombstone === true && newEntry.tombstone === true) {\n        // both props are tombstoned - treat as noop, as there is no data to compare.\n        continue;\n      }\n\n      // both props exist and are not tombstoned, need to compare values with deep equals to see if it was changed\n      const valueChanged = !dequal(currentEntry.data, newEntry.data);\n      if (valueChanged) {\n        update.update[typedKey] = 'updated';\n        continue;\n      }\n    }\n\n    return update;\n  }\n\n  protected _mergeInitialDataFromCreateOperation(\n    objectOperation: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> {\n    if (this._client.Utils.isNil(objectOperation.map)) {\n      // if a map object is missing for the MAP_CREATE op, the initial value is implicitly an empty map.\n      // in this case there is nothing to merge into the current map, so we can just end processing the op.\n      return { update: {}, clientId: msg.clientId, connectionId: msg.connectionId };\n    }\n\n    const aggregatedUpdate: LiveMapUpdate<T> = { update: {}, clientId: msg.clientId, connectionId: msg.connectionId };\n    // RTLM6d1\n    // in order to apply MAP_CREATE op for an existing map, we should merge their underlying entries keys.\n    // we can do this by iterating over entries from MAP_CREATE op and apply changes on per-key basis as if we had MAP_SET, MAP_REMOVE operations.\n    Object.entries(objectOperation.map.entries ?? {}).forEach(([key, entry]) => {\n      // for a MAP_CREATE operation we must use the serial value available on an entry, instead of a serial on a message\n      const opSerial = entry.timeserial;\n      let update: LiveMapUpdate<T> | LiveObjectUpdateNoop;\n      if (entry.tombstone === true) {\n        // RTLM6d1b - entry in MAP_CREATE op is removed, try to apply MAP_REMOVE op\n        update = this._applyMapRemove({ key }, opSerial, entry.serialTimestamp, msg);\n      } else {\n        // RTLM6d1a - entry in MAP_CREATE op is not removed, try to set it via MAP_SET op\n        update = this._applyMapSet({ key, data: entry.data }, opSerial, msg);\n      }\n\n      // skip noop updates\n      if ((update as LiveObjectUpdateNoop).noop) {\n        return;\n      }\n\n      // otherwise copy update data to aggregated update\n      Object.assign(aggregatedUpdate.update, update.update);\n    });\n\n    this._createOperationIsMerged = true; // RTLM6d2\n\n    return aggregatedUpdate;\n  }\n\n  private _throwNoPayloadError(op: ObjectOperation<ObjectData>): void {\n    throw new this._client.ErrorInfo(\n      `No payload found for ${op.action} op for LiveMap objectId=${this.getObjectId()}`,\n      92000,\n      500,\n    );\n  }\n\n  private _applyMapCreate(\n    op: ObjectOperation<ObjectData>,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    if (this._createOperationIsMerged) {\n      // There can't be two different create operation for the same object id, because the object id\n      // fully encodes that operation. This means we can safely ignore any new incoming create operations\n      // if we already merged it once.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap._applyMapCreate()',\n        `skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    if (this._semantics !== op.map?.semantics) {\n      throw new this._client.ErrorInfo(\n        `Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${op.map?.semantics}`,\n        92000,\n        500,\n      );\n    }\n\n    return this._mergeInitialDataFromCreateOperation(op, msg);\n  }\n\n  /** @spec RTLM7 */\n  private _applyMapSet(\n    op: ObjectsMapOp<ObjectData>,\n    opSerial: string | undefined,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    const { ErrorInfo, Utils } = this._client;\n\n    const existingEntry = this._dataRef.data.get(op.key);\n    // RTLM7a\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\n      // RTLM7a1 - the operation's serial <= the entry's serial, ignore the operation.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap._applyMapSet()',\n        `skipping update for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    if (Utils.isNil(op.data) || (Utils.isNil(op.data.objectId) && Utils.isNil(op.data.value))) {\n      throw new ErrorInfo(\n        `Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key=\"${op.key}\"`,\n        92000,\n        500,\n      );\n    }\n\n    let liveData: LiveMapObjectData;\n    // RTLM7c\n    if (!Utils.isNil(op.data.objectId)) {\n      liveData = { objectId: op.data.objectId } as ObjectIdObjectData;\n      // this MAP_SET op is setting a key to point to another object via its object id,\n      // but it is possible that we don't have the corresponding object in the pool yet (for example, we haven't seen the *_CREATE op for it).\n      // we don't want to return undefined from this map's .get() method even if we don't have the object,\n      // so instead we create a zero-value object for that object id if it not exists.\n      this._objects.getPool().createZeroValueObjectIfNotExists(op.data.objectId); // RTLM7c1\n    } else {\n      liveData = { value: op.data.value } as ValueObjectData;\n    }\n\n    if (existingEntry) {\n      // RTLM7a2\n      existingEntry.tombstone = false; // RTLM7a2c\n      existingEntry.tombstonedAt = undefined;\n      existingEntry.timeserial = opSerial; // RTLM7a2b\n      existingEntry.data = liveData; // RTLM7a2a\n    } else {\n      // RTLM7b, RTLM7b1\n      const newEntry: LiveMapEntry = {\n        tombstone: false, // RTLM7b2\n        tombstonedAt: undefined,\n        timeserial: opSerial,\n        data: liveData,\n      };\n      this._dataRef.data.set(op.key, newEntry);\n    }\n\n    const update: LiveMapUpdate<T> = { update: {}, clientId: msg.clientId, connectionId: msg.connectionId };\n    const typedKey: keyof T & string = op.key;\n    update.update[typedKey] = 'updated';\n\n    return update;\n  }\n\n  /** @spec RTLM8 */\n  private _applyMapRemove(\n    op: ObjectsMapOp<ObjectData>,\n    opSerial: string | undefined,\n    opTimestamp: number | undefined,\n    msg: ObjectMessage,\n  ): LiveMapUpdate<T> | LiveObjectUpdateNoop {\n    const existingEntry = this._dataRef.data.get(op.key);\n    // RTLM8a\n    if (existingEntry && !this._canApplyMapOperation(existingEntry.timeserial, opSerial)) {\n      // RTLM8a1 - the operation's serial <= the entry's serial, ignore the operation.\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MICRO,\n        'LiveMap._applyMapRemove()',\n        `skipping remove for key=\"${op.key}\": op serial ${opSerial?.toString()} <= entry serial ${existingEntry.timeserial?.toString()}; objectId=${this.getObjectId()}`,\n      );\n      return { noop: true };\n    }\n\n    let tombstonedAt: number;\n    if (opTimestamp != null) {\n      tombstonedAt = opTimestamp;\n    } else {\n      this._client.Logger.logAction(\n        this._client.logger,\n        this._client.Logger.LOG_MINOR,\n        'LiveMap._applyMapRemove()',\n        `map key has been removed but no \"serialTimestamp\" found in the message, using local clock instead; key=\"${op.key}\", objectId=${this.getObjectId()}`,\n      );\n      tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\n    }\n\n    if (existingEntry) {\n      // RTLM8a2\n      existingEntry.tombstone = true; // RTLM8a2c\n      existingEntry.tombstonedAt = tombstonedAt;\n      existingEntry.timeserial = opSerial; // RTLM8a2b\n      existingEntry.data = undefined; // RTLM8a2a\n    } else {\n      // RTLM8b, RTLM8b1\n      const newEntry: LiveMapEntry = {\n        tombstone: true, // RTLM8b2\n        tombstonedAt: tombstonedAt,\n        timeserial: opSerial,\n        data: undefined,\n      };\n      this._dataRef.data.set(op.key, newEntry);\n    }\n\n    const update: LiveMapUpdate<T> = { update: {}, clientId: msg.clientId, connectionId: msg.connectionId };\n    const typedKey: keyof T & string = op.key;\n    update.update[typedKey] = 'removed';\n\n    return update;\n  }\n\n  /**\n   * Returns true if the serials of the given operation and entry indicate that\n   * the operation should be applied to the entry, following the CRDT semantics of this LiveMap.\n   * @spec RTLM9\n   */\n  private _canApplyMapOperation(mapEntrySerial: string | undefined, opSerial: string | undefined): boolean {\n    // for LWW CRDT semantics (the only supported LiveMap semantic) an operation\n    // should only be applied if its serial is strictly greater (\"after\") than an entry's serial.\n\n    if (!mapEntrySerial && !opSerial) {\n      // RTLM9b - if both serials are nullish or empty strings, we treat them as the \"earliest possible\" serials,\n      // in which case they are \"equal\", so the operation should not be applied\n      return false;\n    }\n\n    if (!mapEntrySerial) {\n      // RTLM9d - any operation serial is greater than non-existing entry serial\n      return true;\n    }\n\n    if (!opSerial) {\n      // RTLM9c - non-existing operation serial is lower than any entry serial\n      return false;\n    }\n\n    // RTLM9e - if both serials exist, compare them lexicographically\n    return opSerial > mapEntrySerial;\n  }\n\n  private _liveMapDataFromMapEntries(entries: Record<string, ObjectsMapEntry<ObjectData>>): LiveMapData {\n    const liveMapData: LiveMapData = {\n      data: new Map<string, LiveMapEntry>(),\n    };\n\n    // need to iterate over entries to correctly process optional parameters\n    Object.entries(entries ?? {}).forEach(([key, entry]) => {\n      let liveData: LiveMapObjectData | undefined = undefined;\n\n      if (!this._client.Utils.isNil(entry.data)) {\n        if (!this._client.Utils.isNil(entry.data.objectId)) {\n          liveData = { objectId: entry.data.objectId } as ObjectIdObjectData;\n        } else {\n          liveData = { value: entry.data.value } as ValueObjectData;\n        }\n      }\n\n      let tombstonedAt: number | undefined;\n      if (entry.tombstone === true) {\n        if (entry.serialTimestamp != null) {\n          tombstonedAt = entry.serialTimestamp;\n        } else {\n          this._client.Logger.logAction(\n            this._client.logger,\n            this._client.Logger.LOG_MINOR,\n            'LiveMap._liveMapDataFromMapEntries()',\n            `map key is removed but no \"serialTimestamp\" found, using local clock instead; key=\"${key}\", objectId=${this.getObjectId()}`,\n          );\n          tombstonedAt = Date.now(); // best-effort estimate since no timestamp provided by the server\n        }\n      }\n\n      const liveDataEntry: LiveMapEntry = {\n        timeserial: entry.timeserial,\n        data: liveData,\n        // consider object as tombstoned only if we received an explicit flag stating that. otherwise it exists\n        tombstone: entry.tombstone === true,\n        tombstonedAt,\n      };\n\n      liveMapData.data.set(key, liveDataEntry);\n    });\n\n    return liveMapData;\n  }\n\n  /**\n   * Returns value as is if object data stores a primitive type, or a reference to another LiveObject from the pool if it stores an objectId.\n   */\n  private _getResolvedValueFromObjectData(data: LiveMapObjectData): PrimitiveObjectValue | LiveObject | undefined {\n    // if object data stores primitive value, just return it as is.\n    const primitiveValue = (data as ValueObjectData).value;\n    if (primitiveValue != null) {\n      return primitiveValue; // RTLM5d2b, RTLM5d2c, RTLM5d2d, RTLM5d2e\n    }\n\n    // RTLM5d2f - otherwise, it has an objectId reference, and we should get the actual object from the pool\n    const objectId = (data as ObjectIdObjectData).objectId;\n    const refObject: LiveObject | undefined = this._objects.getPool().get(objectId);\n    if (!refObject) {\n      return undefined; // RTLM5d2f1\n    }\n\n    if (refObject.isTombstoned()) {\n      // tombstoned objects must not be surfaced to the end users\n      return undefined;\n    }\n\n    return refObject; // RTLM5d2f2\n  }\n\n  private _isMapEntryTombstoned(entry: LiveMapEntry): boolean {\n    if (entry.tombstone === true) {\n      return true;\n    }\n\n    // data always exists for non-tombstoned entries\n    const data = entry.data!;\n    if ('objectId' in data) {\n      const refObject = this._objects.getPool().get(data.objectId);\n\n      if (refObject?.isTombstoned()) {\n        // entry that points to tombstoned object should be considered tombstoned as well\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n", "import type * as API from '../../../ably';\nimport { BatchContext } from './batchcontext';\nimport { LiveMap } from './livemap';\nimport { LiveObject } from './liveobject';\nimport { Objects } from './objects';\n\nexport class BatchContextLiveMap<T extends API.LiveMapType> {\n  constructor(\n    private _batchContext: BatchContext,\n    private _objects: Objects,\n    private _map: LiveMap<T>,\n  ) {}\n\n  get<TKey extends keyof T & string>(key: TKey): T[TKey] | undefined {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n    this._batchContext.throwIfClosed();\n    const value = this._map.get(key);\n    if (value instanceof LiveObject) {\n      return this._batchContext.getWrappedObject(value.getObjectId()) as T[TKey];\n    } else {\n      return value;\n    }\n  }\n\n  size(): number {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n    this._batchContext.throwIfClosed();\n    return this._map.size();\n  }\n\n  *entries<TKey extends keyof T & string>(): IterableIterator<[TKey, T[TKey]]> {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n    this._batchContext.throwIfClosed();\n    yield* this._map.entries();\n  }\n\n  *keys<TKey extends keyof T & string>(): IterableIterator<TKey> {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n    this._batchContext.throwIfClosed();\n    yield* this._map.keys();\n  }\n\n  *values<TKey extends keyof T & string>(): IterableIterator<T[TKey]> {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n    this._batchContext.throwIfClosed();\n    yield* this._map.values();\n  }\n\n  set<TKey extends keyof T & string>(key: TKey, value: T[TKey]): void {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    this._batchContext.throwIfClosed();\n    const msg = LiveMap.createMapSetMessage(this._objects, this._map.getObjectId(), key, value);\n    this._batchContext.queueMessage(msg);\n  }\n\n  remove<TKey extends keyof T & string>(key: TKey): void {\n    this._objects.throwIfInvalidWriteApiConfiguration();\n    this._batchContext.throwIfClosed();\n    const msg = LiveMap.createMapRemoveMessage(this._objects, this._map.getObjectId(), key);\n    this._batchContext.queueMessage(msg);\n  }\n}\n", "export const DEFAULTS = {\n  gcInterval: 1000 * 60 * 5, // 5 minutes\n  /**\n   * The SDK will attempt to use the `objectsGCGracePeriod` value provided by the server in the `connectionDetails` object of the `CONNECTED` event.\n   * If the server does not provide this value, the SDK will fall back to this default value.\n   *\n   * Must be > 2 minutes to ensure we keep tombstones long enough to avoid the possibility of receiving an operation\n   * with an earlier serial that would not have been applied if the tombstone still existed.\n   *\n   * Applies both for map entries tombstones and object tombstones.\n   */\n  gcGracePeriod: 1000 * 60 * 60 * 24, // 24 hours\n};\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport { DEFAULTS } from './defaults';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { LiveObject } from './liveobject';\nimport { ObjectId } from './objectid';\nimport { Objects } from './objects';\n\nexport const ROOT_OBJECT_ID = 'root';\n\n/**\n * @internal\n * @spec RTO3\n */\nexport class ObjectsPool {\n  private _client: BaseClient;\n  private _pool: Map<string, LiveObject>; // RTO3a\n  private _gcInterval: ReturnType<typeof setInterval>;\n\n  constructor(private _objects: Objects) {\n    this._client = this._objects.getClient();\n    this._pool = this._createInitialPool();\n    this._gcInterval = setInterval(() => {\n      this._onGCInterval();\n    }, DEFAULTS.gcInterval);\n    // call nodejs's Timeout.unref to not require Node.js event loop to remain active due to this interval. see https://nodejs.org/api/timers.html#timeoutunref\n    this._gcInterval.unref?.();\n  }\n\n  get(objectId: string): LiveObject | undefined {\n    return this._pool.get(objectId);\n  }\n\n  /**\n   * Deletes objects from the pool for which object ids are not found in the provided array of ids.\n   */\n  deleteExtraObjectIds(objectIds: string[]): void {\n    const poolObjectIds = [...this._pool.keys()];\n    const extraObjectIds = poolObjectIds.filter((x) => !objectIds.includes(x));\n\n    extraObjectIds.forEach((x) => this._pool.delete(x));\n  }\n\n  set(objectId: string, liveObject: LiveObject): void {\n    this._pool.set(objectId, liveObject);\n  }\n\n  /**\n   * Removes all objects but root from the pool and clears the data for root.\n   * Does not create a new root object, so the reference to the root object remains the same.\n   */\n  resetToInitialPool(emitUpdateEvents: boolean): void {\n    // clear the pool first and keep the root object\n    const root = this._pool.get(ROOT_OBJECT_ID)!;\n    this._pool.clear();\n    this._pool.set(root.getObjectId(), root);\n\n    // clear the data, this will only clear the root object\n    this.clearObjectsData(emitUpdateEvents);\n  }\n\n  /**\n   * Clears the data stored for all objects in the pool.\n   */\n  clearObjectsData(emitUpdateEvents: boolean): void {\n    for (const object of this._pool.values()) {\n      const update = object.clearData();\n      if (emitUpdateEvents) {\n        object.notifyUpdated(update);\n      }\n    }\n  }\n\n  /** @spec RTO6 */\n  createZeroValueObjectIfNotExists(objectId: string): LiveObject {\n    const existingObject = this.get(objectId);\n    if (existingObject) {\n      return existingObject; // RTO6a\n    }\n\n    const parsedObjectId = ObjectId.fromString(this._client, objectId); // RTO6b\n    let zeroValueObject: LiveObject;\n    switch (parsedObjectId.type) {\n      case 'map': {\n        zeroValueObject = LiveMap.zeroValue(this._objects, objectId); // RTO6b2\n        break;\n      }\n\n      case 'counter':\n        zeroValueObject = LiveCounter.zeroValue(this._objects, objectId); // RTO6b3\n        break;\n    }\n\n    this.set(objectId, zeroValueObject);\n    return zeroValueObject;\n  }\n\n  private _createInitialPool(): Map<string, LiveObject> {\n    const pool = new Map<string, LiveObject>();\n    // RTO3b\n    const root = LiveMap.zeroValue(this._objects, ROOT_OBJECT_ID);\n    pool.set(root.getObjectId(), root);\n    return pool;\n  }\n\n  private _onGCInterval(): void {\n    const toDelete: string[] = [];\n    for (const [objectId, obj] of this._pool.entries()) {\n      // tombstoned objects should be removed from the pool if they have been tombstoned for longer than grace period.\n      // by removing them from the local pool, Objects plugin no longer keeps a reference to those objects, allowing JS's\n      // Garbage Collection to eventually free the memory for those objects, provided the user no longer references them either.\n      if (obj.isTombstoned() && Date.now() - obj.tombstonedAt()! >= this._objects.gcGracePeriod) {\n        toDelete.push(objectId);\n        continue;\n      }\n\n      obj.onGCInterval();\n    }\n\n    toDelete.forEach((x) => this._pool.delete(x));\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type * as API from '../../../ably';\nimport { BatchContextLiveCounter } from './batchcontextlivecounter';\nimport { BatchContextLiveMap } from './batchcontextlivemap';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { ObjectMessage } from './objectmessage';\nimport { Objects } from './objects';\nimport { ROOT_OBJECT_ID } from './objectspool';\n\nexport class BatchContext {\n  private _client: BaseClient;\n  /** Maps object ids to the corresponding batch context object wrappers  */\n  private _wrappedObjects: Map<string, BatchContextLiveCounter | BatchContextLiveMap<API.LiveMapType>> = new Map();\n  private _queuedMessages: ObjectMessage[] = [];\n  private _isClosed = false;\n\n  constructor(\n    private _objects: Objects,\n    private _root: LiveMap<API.LiveMapType>,\n  ) {\n    this._client = _objects.getClient();\n    this._wrappedObjects.set(this._root.getObjectId(), new BatchContextLiveMap(this, this._objects, this._root));\n  }\n\n  getRoot<T extends API.LiveMapType = API.DefaultRoot>(): BatchContextLiveMap<T> {\n    this._objects.throwIfInvalidAccessApiConfiguration();\n    this.throwIfClosed();\n    return this.getWrappedObject(ROOT_OBJECT_ID) as BatchContextLiveMap<T>;\n  }\n\n  /**\n   * @internal\n   */\n  getWrappedObject(objectId: string): BatchContextLiveCounter | BatchContextLiveMap<API.LiveMapType> | undefined {\n    if (this._wrappedObjects.has(objectId)) {\n      return this._wrappedObjects.get(objectId);\n    }\n\n    const originObject = this._objects.getPool().get(objectId);\n    if (!originObject) {\n      return undefined;\n    }\n\n    let wrappedObject: BatchContextLiveCounter | BatchContextLiveMap<API.LiveMapType>;\n    if (originObject instanceof LiveMap) {\n      wrappedObject = new BatchContextLiveMap(this, this._objects, originObject);\n    } else if (originObject instanceof LiveCounter) {\n      wrappedObject = new BatchContextLiveCounter(this, this._objects, originObject);\n    } else {\n      throw new this._client.ErrorInfo(\n        `Unknown LiveObject instance type: objectId=${originObject.getObjectId()}`,\n        50000,\n        500,\n      );\n    }\n\n    this._wrappedObjects.set(objectId, wrappedObject);\n    return wrappedObject;\n  }\n\n  /**\n   * @internal\n   */\n  throwIfClosed(): void {\n    if (this.isClosed()) {\n      throw new this._client.ErrorInfo('Batch is closed', 40000, 400);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  isClosed(): boolean {\n    return this._isClosed;\n  }\n\n  /**\n   * @internal\n   */\n  close(): void {\n    this._isClosed = true;\n  }\n\n  /**\n   * @internal\n   */\n  queueMessage(msg: ObjectMessage): void {\n    this._queuedMessages.push(msg);\n  }\n\n  /**\n   * @internal\n   */\n  async flush(): Promise<void> {\n    try {\n      this.close();\n\n      if (this._queuedMessages.length > 0) {\n        await this._objects.publish(this._queuedMessages);\n      }\n    } finally {\n      this._wrappedObjects.clear();\n      this._queuedMessages = [];\n    }\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\nimport { ObjectMessage } from './objectmessage';\nimport { Objects } from './objects';\n\nexport interface LiveObjectDataEntry {\n  objectMessage: ObjectMessage;\n  objectType: 'LiveMap' | 'LiveCounter';\n}\n\nexport interface LiveCounterDataEntry extends LiveObjectDataEntry {\n  objectType: 'LiveCounter';\n}\n\nexport interface LiveMapDataEntry extends LiveObjectDataEntry {\n  objectType: 'LiveMap';\n}\n\nexport type AnyDataEntry = LiveCounterDataEntry | LiveMapDataEntry;\n\n// TODO: investigate if this class is still needed after changes with createOp. objects are now initialized from the stateObject and this class does minimal processing\n/**\n * @internal\n */\nexport class SyncObjectsDataPool {\n  private _client: BaseClient;\n  private _channel: RealtimeChannel;\n  private _pool: Map<string, AnyDataEntry>;\n\n  constructor(private _objects: Objects) {\n    this._client = this._objects.getClient();\n    this._channel = this._objects.getChannel();\n    this._pool = new Map<string, AnyDataEntry>();\n  }\n\n  entries() {\n    return this._pool.entries();\n  }\n\n  size(): number {\n    return this._pool.size;\n  }\n\n  isEmpty(): boolean {\n    return this._pool.size === 0;\n  }\n\n  clear(): void {\n    this._pool.clear();\n  }\n\n  applyObjectSyncMessages(objectMessages: ObjectMessage[]): void {\n    for (const objectMessage of objectMessages) {\n      if (!objectMessage.object) {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MAJOR,\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\n          `object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n        );\n        continue;\n      }\n\n      const objectState = objectMessage.object;\n\n      if (objectState.counter) {\n        this._pool.set(objectState.objectId, this._createLiveCounterDataEntry(objectMessage));\n      } else if (objectState.map) {\n        this._pool.set(objectState.objectId, this._createLiveMapDataEntry(objectMessage));\n      } else {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MAJOR,\n          'SyncObjectsDataPool.applyObjectSyncMessages()',\n          `received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n        );\n      }\n    }\n  }\n\n  private _createLiveCounterDataEntry(objectMessage: ObjectMessage): LiveCounterDataEntry {\n    const newEntry: LiveCounterDataEntry = {\n      objectMessage,\n      objectType: 'LiveCounter',\n    };\n\n    return newEntry;\n  }\n\n  private _createLiveMapDataEntry(objectMessage: ObjectMessage): LiveMapDataEntry {\n    const newEntry: LiveMapDataEntry = {\n      objectMessage,\n      objectType: 'LiveMap',\n    };\n\n    return newEntry;\n  }\n}\n", "import type BaseClient from 'common/lib/client/baseclient';\nimport type RealtimeChannel from 'common/lib/client/realtimechannel';\nimport type EventEmitter from 'common/lib/util/eventemitter';\nimport type * as API from '../../../ably';\nimport { BatchContext } from './batchcontext';\nimport { DEFAULTS } from './defaults';\nimport { LiveCounter } from './livecounter';\nimport { LiveMap } from './livemap';\nimport { LiveObject, LiveObjectUpdate, LiveObjectUpdateNoop } from './liveobject';\nimport { ObjectMessage, ObjectOperationAction } from './objectmessage';\nimport { ObjectsPool, ROOT_OBJECT_ID } from './objectspool';\nimport { SyncObjectsDataPool } from './syncobjectsdatapool';\n\nexport enum ObjectsEvent {\n  syncing = 'syncing',\n  synced = 'synced',\n}\n\nexport enum ObjectsState {\n  initialized = 'initialized',\n  syncing = 'syncing',\n  synced = 'synced',\n}\n\nconst StateToEventsMap: Record<ObjectsState, ObjectsEvent | undefined> = {\n  initialized: undefined,\n  syncing: ObjectsEvent.syncing,\n  synced: ObjectsEvent.synced,\n};\n\nexport type ObjectsEventCallback = () => void;\n\nexport interface OnObjectsEventResponse {\n  off(): void;\n}\n\nexport type BatchCallback = (batchContext: BatchContext) => void;\n\nexport class Objects {\n  gcGracePeriod: number;\n\n  private _client: BaseClient;\n  private _channel: RealtimeChannel;\n  private _state: ObjectsState;\n  // composition over inheritance since we cannot import class directly into plugin code.\n  // instead we obtain a class type from the client\n  private _eventEmitterInternal: EventEmitter;\n  // related to RTC10, should have a separate EventEmitter for users of the library\n  private _eventEmitterPublic: EventEmitter;\n  private _objectsPool: ObjectsPool; // RTO3\n  private _syncObjectsDataPool: SyncObjectsDataPool;\n  private _currentSyncId: string | undefined;\n  private _currentSyncCursor: string | undefined;\n  private _bufferedObjectOperations: ObjectMessage[];\n\n  // Used by tests\n  static _DEFAULTS = DEFAULTS;\n\n  constructor(channel: RealtimeChannel) {\n    this._channel = channel;\n    this._client = channel.client;\n    this._state = ObjectsState.initialized;\n    this._eventEmitterInternal = new this._client.EventEmitter(this._client.logger);\n    this._eventEmitterPublic = new this._client.EventEmitter(this._client.logger);\n    this._objectsPool = new ObjectsPool(this);\n    this._syncObjectsDataPool = new SyncObjectsDataPool(this);\n    this._bufferedObjectOperations = [];\n    // use server-provided objectsGCGracePeriod if available, and subscribe to new connectionDetails that can be emitted as part of the RTN24\n    this.gcGracePeriod =\n      this._channel.connectionManager.connectionDetails?.objectsGCGracePeriod ?? DEFAULTS.gcGracePeriod;\n    this._channel.connectionManager.on('connectiondetails', (details: Record<string, any>) => {\n      this.gcGracePeriod = details.objectsGCGracePeriod ?? DEFAULTS.gcGracePeriod;\n    });\n  }\n\n  /**\n   * When called without a type variable, we return a default root type which is based on globally defined interface for Objects feature.\n   * A user can provide an explicit type for the getRoot method to explicitly set the type structure on this particular channel.\n   * This is useful when working with multiple channels with different underlying data structure.\n   * @spec RTO1\n   */\n  async getRoot<T extends API.LiveMapType = API.DefaultRoot>(): Promise<LiveMap<T>> {\n    this.throwIfInvalidAccessApiConfiguration(); // RTO1a, RTO1b\n\n    // if we're not synced yet, wait for sync sequence to finish before returning root\n    if (this._state !== ObjectsState.synced) {\n      await this._eventEmitterInternal.once(ObjectsEvent.synced); // RTO1c\n    }\n\n    return this._objectsPool.get(ROOT_OBJECT_ID) as LiveMap<T>; // RTO1d\n  }\n\n  /**\n   * Provides access to the synchronous write API for Objects that can be used to batch multiple operations together in a single channel message.\n   */\n  async batch(callback: BatchCallback): Promise<void> {\n    this.throwIfInvalidWriteApiConfiguration();\n\n    const root = await this.getRoot();\n    const context = new BatchContext(this, root);\n\n    try {\n      callback(context);\n      await context.flush();\n    } finally {\n      context.close();\n    }\n  }\n\n  /**\n   * Send a MAP_CREATE operation to the realtime system to create a new map object in the pool.\n   *\n   * Once the ACK message is received, the method returns the object from the local pool if it got created due to\n   * the echoed MAP_CREATE operation, or if it wasn't received yet, the method creates a new object locally using the provided data and returns it.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message. A promise is resolved with an object containing provided data.\n   */\n  async createMap<T extends API.LiveMapType>(entries?: T): Promise<LiveMap<T>> {\n    this.throwIfInvalidWriteApiConfiguration();\n\n    const msg = await LiveMap.createMapCreateMessage(this, entries);\n    const objectId = msg.operation?.objectId!;\n\n    await this.publish([msg]);\n\n    // we may have already received the MAP_CREATE operation at this point, as it could arrive before the ACK for our publish message.\n    // this means the object might already exist in the local pool, having been added during the usual MAP_CREATE operation process.\n    // here we check if the object is present, and return it if found; otherwise, create a new object on the client side.\n    if (this._objectsPool.get(objectId)) {\n      return this._objectsPool.get(objectId) as LiveMap<T>;\n    }\n\n    // we haven't received the MAP_CREATE operation yet, so we can create a new map object using the locally constructed object operation.\n    // we don't know the serials for map entries, so we assign an \"earliest possible\" serial to each entry, so that any subsequent operation can be applied to them.\n    // we mark the MAP_CREATE operation as merged for the object, guaranteeing its idempotency and preventing it from being applied again when the operation arrives.\n    const map = LiveMap.fromObjectOperation<T>(this, msg);\n    this._objectsPool.set(objectId, map);\n\n    return map;\n  }\n\n  /**\n   * Send a COUNTER_CREATE operation to the realtime system to create a new counter object in the pool.\n   *\n   * Once the ACK message is received, the method returns the object from the local pool if it got created due to\n   * the echoed COUNTER_CREATE operation, or if it wasn't received yet, the method creates a new object locally using the provided data and returns it.\n   *\n   * @returns A promise which resolves upon receiving the ACK message for the published operation message. A promise is resolved with an object containing provided data.\n   */\n  async createCounter(count?: number): Promise<LiveCounter> {\n    this.throwIfInvalidWriteApiConfiguration();\n\n    const msg = await LiveCounter.createCounterCreateMessage(this, count);\n    const objectId = msg.operation?.objectId!;\n\n    await this.publish([msg]);\n\n    // we may have already received the COUNTER_CREATE operation at this point, as it could arrive before the ACK for our publish message.\n    // this means the object might already exist in the local pool, having been added during the usual COUNTER_CREATE operation process.\n    // here we check if the object is present, and return it if found; otherwise, create a new object on the client side.\n    if (this._objectsPool.get(objectId)) {\n      return this._objectsPool.get(objectId) as LiveCounter;\n    }\n\n    // we haven't received the COUNTER_CREATE operation yet, so we can create a new counter object using the locally constructed object operation.\n    // we mark the COUNTER_CREATE operation as merged for the object, guaranteeing its idempotency. this ensures we don't double count the initial counter value when the operation arrives.\n    const counter = LiveCounter.fromObjectOperation(this, msg);\n    this._objectsPool.set(objectId, counter);\n\n    return counter;\n  }\n\n  on(event: ObjectsEvent, callback: ObjectsEventCallback): OnObjectsEventResponse {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n    this._eventEmitterPublic.on(event, callback);\n\n    const off = () => {\n      this._eventEmitterPublic.off(event, callback);\n    };\n\n    return { off };\n  }\n\n  off(event: ObjectsEvent, callback: ObjectsEventCallback): void {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n\n    // prevent accidentally calling .off without any arguments on an EventEmitter and removing all callbacks\n    if (this._client.Utils.isNil(event) && this._client.Utils.isNil(callback)) {\n      return;\n    }\n\n    this._eventEmitterPublic.off(event, callback);\n  }\n\n  offAll(): void {\n    // this public API method can be called without specific configuration, so checking for invalid settings is unnecessary.\n    this._eventEmitterPublic.off();\n  }\n\n  /**\n   * @internal\n   */\n  getPool(): ObjectsPool {\n    return this._objectsPool;\n  }\n\n  /**\n   * @internal\n   */\n  getChannel(): RealtimeChannel {\n    return this._channel;\n  }\n\n  /**\n   * @internal\n   */\n  getClient(): BaseClient {\n    return this._client;\n  }\n\n  /**\n   * @internal\n   * @spec RTO5\n   */\n  handleObjectSyncMessages(objectMessages: ObjectMessage[], syncChannelSerial: string | null | undefined): void {\n    const { syncId, syncCursor } = this._parseSyncChannelSerial(syncChannelSerial); // RTO5a\n    const newSyncSequence = this._currentSyncId !== syncId;\n    if (newSyncSequence) {\n      // RTO5a2 - new sync sequence started\n      this._startNewSync(syncId, syncCursor); // RTO5a2a\n    }\n\n    // RTO5a3 - continue current sync sequence\n    this._syncObjectsDataPool.applyObjectSyncMessages(objectMessages); // RTO5b\n\n    // RTO5a4 - if this is the last (or only) message in a sequence of sync updates, end the sync\n    if (!syncCursor) {\n      // defer the state change event until the next tick if this was a new sync sequence\n      // to allow any event listeners to process the start of the new sequence event that was emitted earlier during this event loop.\n      this._endSync(newSyncSequence);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  handleObjectMessages(objectMessages: ObjectMessage[]): void {\n    if (this._state !== ObjectsState.synced) {\n      // The client receives object messages in realtime over the channel concurrently with the sync sequence.\n      // Some of the incoming object messages may have already been applied to the objects described in\n      // the sync sequence, but others may not; therefore we must buffer these messages so that we can apply\n      // them to the objects once the sync is complete.\n      this._bufferedObjectOperations.push(...objectMessages);\n      return;\n    }\n\n    this._applyObjectMessages(objectMessages);\n  }\n\n  /**\n   * @internal\n   * @spec RTO4\n   */\n  onAttached(hasObjects?: boolean): void {\n    this._client.Logger.logAction(\n      this._client.logger,\n      this._client.Logger.LOG_MINOR,\n      'Objects.onAttached()',\n      `channel=${this._channel.name}, hasObjects=${hasObjects}`,\n    );\n\n    // RTO4a\n    const fromInitializedState = this._state === ObjectsState.initialized;\n    if (hasObjects || fromInitializedState) {\n      // should always start a new sync sequence if we're in the initialized state, no matter the HAS_OBJECTS flag value.\n      // this guarantees we emit both \"syncing\" -> \"synced\" events in that order.\n      this._startNewSync();\n    }\n\n    // RTO4b\n    if (!hasObjects) {\n      // if no HAS_OBJECTS flag received on attach, we can end sync sequence immediately and treat it as no objects on a channel.\n      // reset the objects pool to its initial state, and emit update events so subscribers to root object get notified about changes.\n      this._objectsPool.resetToInitialPool(true); // RTO4b1, RTO4b2\n      this._syncObjectsDataPool.clear(); // RTO4b3\n      // defer the state change event until the next tick if we started a new sequence just now due to being in initialized state.\n      // this allows any event listeners to process the start of the new sequence event that was emitted earlier during this event loop.\n      this._endSync(fromInitializedState); // RTO4b4\n    }\n  }\n\n  /**\n   * @internal\n   */\n  actOnChannelState(state: API.ChannelState, hasObjects?: boolean): void {\n    switch (state) {\n      case 'attached':\n        this.onAttached(hasObjects);\n        break;\n\n      case 'detached':\n      case 'failed':\n        // do not emit data update events as the actual current state of Objects data is unknown when we're in these channel states\n        this._objectsPool.clearObjectsData(false);\n        this._syncObjectsDataPool.clear();\n        break;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async publish(objectMessages: ObjectMessage[]): Promise<void> {\n    this._channel.throwIfUnpublishableState();\n\n    const encodedMsgs = objectMessages.map((x) => x.encode(this._client));\n    const maxMessageSize = this._client.options.maxMessageSize;\n    const size = encodedMsgs.reduce((acc, msg) => acc + msg.getMessageSize(), 0);\n    if (size > maxMessageSize) {\n      throw new this._client.ErrorInfo(\n        `Maximum size of object messages that can be published at once exceeded (was ${size} bytes; limit is ${maxMessageSize} bytes)`,\n        40009,\n        400,\n      );\n    }\n\n    return this._channel.sendState(encodedMsgs);\n  }\n\n  /**\n   * @internal\n   */\n  throwIfInvalidAccessApiConfiguration(): void {\n    this._throwIfMissingChannelMode('object_subscribe');\n    this._throwIfInChannelState(['detached', 'failed']);\n  }\n\n  /**\n   * @internal\n   */\n  throwIfInvalidWriteApiConfiguration(): void {\n    this._throwIfMissingChannelMode('object_publish');\n    this._throwIfInChannelState(['detached', 'failed', 'suspended']);\n    this._throwIfEchoMessagesDisabled();\n  }\n\n  private _startNewSync(syncId?: string, syncCursor?: string): void {\n    // need to discard all buffered object operation messages on new sync start\n    this._bufferedObjectOperations = [];\n    this._syncObjectsDataPool.clear();\n    this._currentSyncId = syncId;\n    this._currentSyncCursor = syncCursor;\n    this._stateChange(ObjectsState.syncing, false);\n  }\n\n  /** @spec RTO5c */\n  private _endSync(deferStateEvent: boolean): void {\n    this._applySync();\n    // should apply buffered object operations after we applied the sync.\n    // can use regular object messages application logic\n    this._applyObjectMessages(this._bufferedObjectOperations);\n\n    this._bufferedObjectOperations = [];\n    this._syncObjectsDataPool.clear(); // RTO5c4\n    this._currentSyncId = undefined; // RTO5c3\n    this._currentSyncCursor = undefined; // RTO5c3\n    this._stateChange(ObjectsState.synced, deferStateEvent);\n  }\n\n  private _parseSyncChannelSerial(syncChannelSerial: string | null | undefined): {\n    syncId: string | undefined;\n    syncCursor: string | undefined;\n  } {\n    let match: RegExpMatchArray | null;\n    let syncId: string | undefined = undefined;\n    let syncCursor: string | undefined = undefined;\n    // RTO5a1 - syncChannelSerial is a two-part identifier: <sequence id>:<cursor value>\n    if (syncChannelSerial && (match = syncChannelSerial.match(/^([\\w-]+):(.*)$/))) {\n      syncId = match[1];\n      syncCursor = match[2];\n    }\n\n    return {\n      syncId,\n      syncCursor,\n    };\n  }\n\n  private _applySync(): void {\n    if (this._syncObjectsDataPool.isEmpty()) {\n      return;\n    }\n\n    const receivedObjectIds = new Set<string>();\n    const existingObjectUpdates: { object: LiveObject; update: LiveObjectUpdate | LiveObjectUpdateNoop }[] = [];\n\n    // RTO5c1\n    for (const [objectId, entry] of this._syncObjectsDataPool.entries()) {\n      receivedObjectIds.add(objectId);\n      const existingObject = this._objectsPool.get(objectId);\n\n      // RTO5c1a\n      if (existingObject) {\n        const update = existingObject.overrideWithObjectState(entry.objectMessage); // RTO5c1a1\n        // store updates to call subscription callbacks for all of them once the sync sequence is completed.\n        // this will ensure that clients get notified about the changes only once everything has been applied.\n        existingObjectUpdates.push({ object: existingObject, update });\n        continue;\n      }\n\n      // RTO5c1b,\n      let newObject: LiveObject;\n      // assign to a variable so TS doesn't complain about 'never' type in the default case\n      const objectType = entry.objectType;\n      switch (objectType) {\n        case 'LiveCounter':\n          newObject = LiveCounter.fromObjectState(this, entry.objectMessage); // RTO5c1b1a\n          break;\n\n        case 'LiveMap':\n          newObject = LiveMap.fromObjectState(this, entry.objectMessage); // RTO5c1b1b\n          break;\n\n        default:\n          throw new this._client.ErrorInfo(`Unknown LiveObject type: ${objectType}`, 50000, 500); // RTO5c1b1c\n      }\n\n      this._objectsPool.set(objectId, newObject); // RTO5c1b1\n    }\n\n    // RTO5c2 - need to remove LiveObject instances from the ObjectsPool for which objectIds were not received during the sync sequence\n    this._objectsPool.deleteExtraObjectIds([...receivedObjectIds]);\n\n    // call subscription callbacks for all updated existing objects\n    existingObjectUpdates.forEach(({ object, update }) => object.notifyUpdated(update));\n  }\n\n  private _applyObjectMessages(objectMessages: ObjectMessage[]): void {\n    for (const objectMessage of objectMessages) {\n      if (!objectMessage.operation) {\n        this._client.Logger.logAction(\n          this._client.logger,\n          this._client.Logger.LOG_MAJOR,\n          'Objects._applyObjectMessages()',\n          `object operation message is received without 'operation' field, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n        );\n        continue;\n      }\n\n      const objectOperation = objectMessage.operation;\n\n      switch (objectOperation.action) {\n        case ObjectOperationAction.MAP_CREATE:\n        case ObjectOperationAction.COUNTER_CREATE:\n        case ObjectOperationAction.MAP_SET:\n        case ObjectOperationAction.MAP_REMOVE:\n        case ObjectOperationAction.COUNTER_INC:\n        case ObjectOperationAction.OBJECT_DELETE:\n          // we can receive an op for an object id we don't have yet in the pool. instead of buffering such operations,\n          // we can create a zero-value object for the provided object id and apply the operation to that zero-value object.\n          // this also means that all objects are capable of applying the corresponding *_CREATE ops on themselves,\n          // since they need to be able to eventually initialize themselves from that *_CREATE op.\n          // so to simplify operations handling, we always try to create a zero-value object in the pool first,\n          // and then we can always apply the operation on the existing object in the pool.\n          this._objectsPool.createZeroValueObjectIfNotExists(objectOperation.objectId);\n          this._objectsPool.get(objectOperation.objectId)!.applyOperation(objectOperation, objectMessage);\n          break;\n\n        default:\n          this._client.Logger.logAction(\n            this._client.logger,\n            this._client.Logger.LOG_MAJOR,\n            'Objects._applyObjectMessages()',\n            `received unsupported action in object operation message: ${objectOperation.action}, skipping message; message id: ${objectMessage.id}, channel: ${this._channel.name}`,\n          );\n      }\n    }\n  }\n\n  /** @spec RTO2 */\n  private _throwIfMissingChannelMode(expectedMode: 'object_subscribe' | 'object_publish'): void {\n    // RTO2a - channel.modes is only populated on channel attachment, so use it only if it is set\n    if (this._channel.modes != null && !this._channel.modes.includes(expectedMode)) {\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400); // RTO2a2\n    }\n    // RTO2b - otherwise as a best effort use user provided channel options\n    if (!this._client.Utils.allToLowerCase(this._channel.channelOptions.modes ?? []).includes(expectedMode)) {\n      throw new this._client.ErrorInfo(`\"${expectedMode}\" channel mode must be set for this operation`, 40024, 400); // RTO2b2\n    }\n  }\n\n  private _stateChange(state: ObjectsState, deferEvent: boolean): void {\n    if (this._state === state) {\n      return;\n    }\n\n    this._state = state;\n    const event = StateToEventsMap[state];\n    if (!event) {\n      return;\n    }\n\n    if (deferEvent) {\n      this._client.Platform.Config.nextTick(() => {\n        this._eventEmitterInternal.emit(event);\n        this._eventEmitterPublic.emit(event);\n      });\n    } else {\n      this._eventEmitterInternal.emit(event);\n      this._eventEmitterPublic.emit(event);\n    }\n  }\n\n  private _throwIfInChannelState(channelState: API.ChannelState[]): void {\n    if (channelState.includes(this._channel.state)) {\n      throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError());\n    }\n  }\n\n  private _throwIfEchoMessagesDisabled(): void {\n    if (this._channel.client.options.echoMessages === false) {\n      throw new this._channel.client.ErrorInfo(\n        `\"echoMessages\" client option must be enabled for this operation`,\n        40000,\n        400,\n      );\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["objects_exports", "__export", "ObjectMessage", "Objects", "WireObjectMessage", "objects_default", "__toCommonJS", "encode", "message", "utils", "messageEncoding", "encodeObjectDataFn", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "_k", "_l", "result", "WireObjectMessage", "copyMsg", "encodeMapEntries", "encodeObjectData", "mapEntries", "encodeFn", "acc", "v", "key", "entry", "encodedData", "__spreadProps", "__spreadValues", "data", "createInitialValueJSONString", "operation", "client", "wireMsg", "ObjectMessage", "encodedOperation", "strMsg", "msg", "className", "attr", "_ObjectMessage", "_utils", "_messageEncoding", "values", "x", "encodedObjectData", "_WireObjectMessage", "format", "error", "__objRest", "size", "obj", "map", "counter", "mapOp", "decodedData", "objectData", "decodedBytes", "decodedJson", "LiveObject", "_objects", "objectId", "listener", "event", "callback", "update", "objectMessage", "previousDataRef", "opSerial", "opSiteCode", "siteSerial", "ObjectId", "_ObjectId", "type", "hash", "msTimestamp", "platform", "objectType", "initialValue", "nonce", "valueForHashBuffer", "hashBuffer", "client", "objectId", "rest", "LiveCounter", "_LiveCounter", "LiveObject", "objects", "objectId", "objectMessage", "obj", "amount", "client", "ObjectMessage", "count", "initialValueOperation", "initialValueJSONString", "createInitialValueJSONString", "nonce", "msTimestamp", "ObjectId", "__spreadProps", "__spreadValues", "msg", "op", "_a", "opSerial", "opSiteCode", "update", "_b", "_c", "_d", "_e", "objectState", "previousDataRef", "prevDataRef", "newDataRef", "objectOperation", "BatchContextLiveCounter", "_batchContext", "_objects", "_counter", "amount", "msg", "LiveCounter", "has", "find", "iter", "tar", "key", "dequal", "foo", "bar", "ctor", "len", "tmp", "LiveMap", "_LiveMap", "LiveObject", "objects", "_semantics", "objectId", "objectMessage", "obj", "_a", "key", "value", "client", "objectData", "ObjectMessage", "entries", "initialValueOperation", "initialValueJSONString", "createInitialValueJSONString", "nonce", "msTimestamp", "ObjectId", "__spreadProps", "__spreadValues", "mapEntries", "element", "size", "entry", "_", "msg", "op", "opSerial", "opSiteCode", "update", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "objectState", "previousDataRef", "keysToDelete", "x", "prevDataRef", "newDataRef", "currentEntry", "typedKey", "newEntry", "dequal", "objectOperation", "aggregatedUpdate", "ErrorInfo", "Utils", "existingEntry", "liveData", "opTimestamp", "tombstonedAt", "mapEntrySerial", "liveMapData", "liveDataEntry", "data", "primitiveValue", "refObject", "BatchContextLiveMap", "_batchContext", "_objects", "_map", "key", "value", "LiveObject", "__yieldStar", "msg", "LiveMap", "DEFAULTS", "ROOT_OBJECT_ID", "ObjectsPool", "_objects", "_a", "_b", "DEFAULTS", "objectId", "objectIds", "x", "liveObject", "emitUpdateEvents", "root", "object", "update", "existingObject", "parsedObjectId", "ObjectId", "zeroValueObject", "LiveMap", "LiveCounter", "pool", "toDelete", "obj", "BatchContext", "_objects", "_root", "BatchContextLiveMap", "ROOT_OBJECT_ID", "objectId", "originObject", "wrappedObject", "LiveMap", "LiveCounter", "BatchContextLiveCounter", "msg", "SyncObjectsDataPool", "_objects", "objectMessages", "objectMessage", "objectState", "StateToEventsMap", "Objects", "channel", "_a", "_b", "ObjectsPool", "SyncObjectsDataPool", "DEFAULTS", "details", "ROOT_OBJECT_ID", "callback", "root", "context", "BatchContext", "entries", "msg", "LiveMap", "objectId", "map", "count", "LiveCounter", "counter", "event", "objectMessages", "syncChannelSerial", "syncId", "syncCursor", "newSyncSequence", "hasObjects", "fromInitializedState", "state", "encodedMsgs", "x", "maxMessageSize", "size", "acc", "deferStateEvent", "match", "receivedObjectIds", "existingObjectUpdates", "entry", "existingObject", "update", "newObject", "objectType", "object", "objectMessage", "objectOperation", "expectedMode", "deferEvent", "channelState", "objects_default", "Objects", "ObjectMessage", "WireObjectMessage"]
}
